[{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"what-is-vertical-data-partitioning","dir":"Articles","previous_headings":"","what":"What is Vertical Data Partitioning?","title":"Getting Started with dsVertClient","text":"traditional horizontal partitioning (standard DataSHIELD scenario), different institutions hold data different patients variables. example, Hospital 1,000 patients Hospital B 2,000 different patients, measure things (age, blood pressure, lab results, etc.). Vertical partitioning fundamentally different: multiple institutions hold data patients different variables. commonly occurs : hospital clinical data (diagnoses, treatments, vital signs) laboratory biomarker measurements (glucose, cholesterol, HbA1c) research center genomic imaging data government registry demographic socioeconomic data institutions records individuals, linked common identifier (e.g., national health number), holds different pieces information.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"illustrative-example","dir":"Articles","previous_headings":"What is Vertical Data Partitioning?","what":"Illustrative Example","title":"Getting Started with dsVertClient","text":"Consider three institutions hold data set patients: researcher wants study whether genetic markers (Center C) associated metabolic outcomes (Lab B), controlling demographics (Hospital ). Answering question requires combining variables three institutions – data pooled due privacy regulations.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"the-privacy-challenge","dir":"Articles","previous_headings":"","what":"The Privacy Challenge","title":"Getting Started with dsVertClient","text":"analyze relationships variables held different institutions (e.g., “glucose level correlate genetic markers?”), traditional approach : Send data central location Merge datasets patient identifier Perform analysis combined table centralization approach raises serious concerns: Patient privacy: Sensitive health data leaves protected environment Legal barriers: GDPR, HIPAA, regulations restrict data transfers Trust issues: Institutions may trust (central party) data Data governance: institution may different consent frameworks","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"the-datashield-solution","dir":"Articles","previous_headings":"","what":"The DataSHIELD Solution","title":"Getting Started with dsVertClient","text":"DataSHIELD framework privacy-preserving federated analysis. key principle : “Bring analysis data, data analysis.” Instead moving data, DataSHIELD: Sends analysis commands server server executes computations locally data non-disclosive aggregate results returned analyst analyst’s client combines aggregates produce final result dsVertClient extends DataSHIELD specifically vertically partitioned data, adding three capabilities standard DataSHIELD provide: Privacy-preserving record alignment via cryptographic hashing Cross-server correlation PCA using Multiparty Homomorphic Encryption (MHE) Distributed GLM fitting using Block Coordinate Descent (BCD)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Getting Started with dsVertClient","text":"using dsVertClient, need: R (>= 4.0.0) installed local machine dsVertClient installed (client-side package run locally) dsVert installed Opal server (server-side companion package) Opal servers set accessible, hosting one data partition Login credentials (username, password, URL) Opal server Install client package GitHub:","code":"# install.packages(\"remotes\") remotes::install_github(\"isglobal-brge/dsVertClient\")"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"connecting-to-opal-servers","dir":"Articles","previous_headings":"","what":"Connecting to Opal Servers","title":"Getting Started with dsVertClient","text":"real deployment, institution runs Opal server hosts data behind firewall. analyst connects servers local R session using DSI (DataSHIELD Interface) package.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"building-login-credentials","dir":"Articles","previous_headings":"Connecting to Opal Servers","what":"Building Login Credentials","title":"Getting Started with dsVertClient","text":"Use DSI::newDSLoginBuilder() assemble connection details server. entry specifies server name, URL, table containing data, authentication credentials:","code":"library(dsVertClient) library(DSI)  builder <- DSI::newDSLoginBuilder()  builder$append(   server = \"hospital_A\",   url = \"https://opal-hospital-a.example.org\",   user = \"analyst\",   password = \"secret_A\",   table = \"project.clinical_data\" )  builder$append(   server = \"lab_B\",   url = \"https://opal-lab-b.example.org\",   user = \"analyst\",   password = \"secret_B\",   table = \"project.lab_results\" )  builder$append(   server = \"research_C\",   url = \"https://opal-research-c.example.org\",   user = \"analyst\",   password = \"secret_C\",   table = \"project.genomic_data\" )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"logging-in","dir":"Articles","previous_headings":"Connecting to Opal Servers","what":"Logging In","title":"Getting Started with dsVertClient","text":"datashield.login() call establishes connections servers simultaneously assigns data server-side symbol (\"D\"): call, server data frame called D R session. analyst never sees raw data – server-side symbol name.","code":"connections <- DSI::datashield.login(   logins = builder$build(),   assign = TRUE,   symbol = \"D\" )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"step-1-validate-identifier-formats","dir":"Articles","previous_headings":"","what":"Step 1: Validate Identifier Formats","title":"Getting Started with dsVertClient","text":"aligning records across servers, important verify patient identifiers consistent format every institution. Common pitfalls include: Different ID formats across institutions (e.g., \"001\" vs \"1\" vs \"P-001\") Leading trailing whitespace Missing values duplicate identifiers Type mismatches (numeric vs character) ds.validateIdFormat() function checks without revealing actual identifier values: output reports, server: n_obs: Total number records n_unique: Number unique identifiers (equal n_obs) n_missing: Number missing identifiers (0) format_signature: hashed summary ID format (match across servers) valid field TRUE, formats consistent can proceed alignment. issues detected, warnings field describe needs fixed. can also validate specific pattern:","code":"validation <- ds.validateIdFormat(   data_name = \"D\",   id_col = \"patient_id\",   datasources = connections )  print(validation) validation <- ds.validateIdFormat(   data_name = \"D\",   id_col = \"patient_id\",   pattern = \"^PATIENT_[0-9]{5}$\",   datasources = connections )"},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"why-alignment-is-needed","dir":"Articles","previous_headings":"Step 2: Privacy-Preserving Record Alignment","what":"Why Alignment is Needed","title":"Getting Started with dsVertClient","text":"Even though institutions data patients, records stored different orders. Institution might patient “P042” row 1, Institution B patient row 157. compute cross-server statistics (e.g., correlation age Hospital glucose Lab B), corresponding records must row position every server. simply share patient IDs servers. expose potentially sensitive identifiers across institutional boundaries.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"the-solution-cryptographic-hashing","dir":"Articles","previous_headings":"Step 2: Privacy-Preserving Record Alignment","what":"The Solution: Cryptographic Hashing","title":"Getting Started with dsVertClient","text":"dsVertClient aligns records using SHA-256 cryptographic hashing: One server designated reference server reference server hashes patient identifiers using SHA-256 hashed values sent servers (hashes one-way – original IDs recovered) server hashes identifiers, matches reference hashes, reorders data accordingly alignment, servers records order, shared patients retained Given hash, recovering original identifier computationally infeasible.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"step-2a-obtain-reference-hashes","dir":"Articles","previous_headings":"Step 2: Privacy-Preserving Record Alignment","what":"Step 2a: Obtain Reference Hashes","title":"Getting Started with dsVertClient","text":"Choose one server reference retrieve hashed identifiers:","code":"ref_hashes <- ds.hashId(   data_name = \"D\",   id_col = \"patient_id\",   algo = \"sha256\",   datasource = connections[\"hospital_A\"] )  # ref_hashes$n      -- number of hashed identifiers # ref_hashes$hashes -- character vector of SHA-256 hashes"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"step-2b-align-all-servers","dir":"Articles","previous_headings":"Step 2: Privacy-Preserving Record Alignment","what":"Step 2b: Align All Servers","title":"Getting Started with dsVertClient","text":"Send reference hashes servers (including reference server ). server : Hash identifiers using algorithm Match reference hashes Reorder data match reference order Drop records present reference set Store result new server-side data frame function prints alignment statistics server, example: server matches fewer 100% records, means reference patients present institution. intersection (patients present institutions) retained. alignment, every server data frame called D_aligned : number rows Rows order (row position corresponds patient) Ready cross-server statistical analysis","code":"ds.alignRecords(   data_name = \"D\",   id_col = \"patient_id\",   reference_hashes = ref_hashes$hashes,   newobj = \"D_aligned\",   datasources = connections ) Server 'hospital_A': 200 of 200 records matched (100.0%) Server 'lab_B': 195 of 200 records matched (97.5%) Server 'research_C': 198 of 200 records matched (99.0%)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"why-multiparty-homomorphic-encryption-mhe-is-needed","dir":"Articles","previous_headings":"","what":"Why Multiparty Homomorphic Encryption (MHE) is Needed","title":"Getting Started with dsVertClient","text":"records aligned, might wonder: can simply compute statistics exchanging summary values servers? analyses, fitting GLM via Block Coordinate Descent, sharing aggregate linear predictor contributions sufficient reveal individual-level data. However, cross-server correlation PCA, situation delicate. Computing correlation variable Server variable Server B fundamentally requires combining information individual observations across servers. Standard summary statistics (means, variances) computed server separately enough – cross-server covariance requires knowledge paired values. dsVertClient solves using Multiparty Homomorphic Encryption (MHE) threshold decryption. protocol works follows: Key generation: server generates secret key share public key share. single server (analyst) holds complete decryption key. Collective public key: public key shares combined Collective Public Key (CPK). Data encrypted CPK can decrypted servers cooperate. Encrypted computation: server standardizes data, encrypts columns CPK, shares ciphertexts. Another server can compute encrypted cross-product (correlation numerator) homomorphically – , operating directly ciphertexts without ever decrypting data. Threshold decryption: encrypted result partially decrypted server using secret key share. analyst collects partial shares fuses recover final aggregate statistic (correlation coefficient). individual data values ever revealed. approach provides strong security guarantees: single point trust: Even analyst decrypt individual data Collusion resistance: K-1 colluding servers decrypt without K-th server Minimal disclosure: final correlation coefficients revealed ds.vertCor() ds.vertPCA() functions handle entire MHE protocol automatically. analyst’s perspective, interface straightforward: GLM function, ds.vertGLM(), uses different approach (Block Coordinate Descent) require MHE, shares linear predictor contributions rather encrypted individual values:","code":"# Define which variables are on which server variables <- list(   hospital_A  = c(\"age\", \"weight\"),   lab_B       = c(\"glucose\", \"cholesterol\"),   research_C  = c(\"gene_score_1\", \"gene_score_2\") )  # Compute the full 6x6 correlation matrix across all servers cor_result <- ds.vertCor(   data_name = \"D_aligned\",   variables = variables,   datasources = connections )  print(cor_result) model <- ds.vertGLM(   data_name = \"D_aligned\",   y_var = \"outcome_bp\",   x_vars = list(     hospital_A = c(\"age\", \"weight\"),     lab_B      = c(\"glucose\"),     research_C = c(\"gene_score_1\")   ),   family = \"gaussian\",   datasources = connections )  summary(model)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"logging-out","dir":"Articles","previous_headings":"","what":"Logging Out","title":"Getting Started with dsVertClient","text":"analysis complete, close server connections:","code":"DSI::datashield.logout(connections)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"summary-of-the-workflow","dir":"Articles","previous_headings":"","what":"Summary of the Workflow","title":"Getting Started with dsVertClient","text":"typical dsVertClient analysis follows steps: Connect Opal servers using DSI::datashield.login() Validate identifier formats ds.validateIdFormat() Hash identifiers reference server ds.hashId() Align records across servers ds.alignRecords() Analyze using ds.vertCor(), ds.vertPCA(), ds.vertGLM() Disconnect DSI::datashield.logout()","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"Further Reading","title":"Getting Started with dsVertClient","text":"Statistical Analysis: Detailed examples correlation, PCA, GLM (Gaussian, binomial, Poisson, Gamma, inverse Gaussian) interpretation guidance visualizations. Methodology: Mathematical foundations Block Coordinate Descent GLMs, MHE threshold decryption protocol correlation/PCA, security model.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Statistical Analysis with dsVertClient","text":"running statistical analysis, records must aligned across servers row position corresponds patient everywhere. Getting Started vignette covers connection setup, identifier validation, record alignment detail. assume following environment already place:","code":"library(dsVertClient) library(DSI)  # Three institutions, already connected and with data assigned to \"D\" # inst_A holds: age, weight         (plus outcome variables) # inst_B holds: height, bmi         (plus outcome variables) # inst_C holds: glucose, cholesterol (plus outcome variables)  # Records have been aligned into \"D_aligned\" using ds.hashId + ds.alignRecords # (see the Getting Started vignette)"},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"the-challenge","dir":"Articles","previous_headings":"Step 1: Correlation Analysis","what":"The Challenge","title":"Statistical Analysis with dsVertClient","text":"Computing correlations across vertically partitioned data non-trivial. Consider computing correlation age (Institution ) glucose (Institution C): Institution knows age values glucose Institution C knows glucose values age Neither can compute correlation alone send raw values institutions","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"the-solution-multiparty-homomorphic-encryption-mhe","dir":"Articles","previous_headings":"Step 1: Correlation Analysis","what":"The Solution: Multiparty Homomorphic Encryption (MHE)","title":"Statistical Analysis with dsVertClient","text":"ds.vertCor uses Multiparty Homomorphic Encryption (MHE) threshold decryption compute cross-server correlations without exposing raw data. protocol proceeds six phases: Key Generation – server generates secret key share public key share. One server also generates Common Reference Polynomial (CRP) shared parties. Key Combination – Public key shares combined Collective Public Key (CPK). Data encrypted CPK can decrypted servers cooperate. Encryption – server standardizes columns (Z-scores) encrypts column--column CPK using CKKS approximate homomorphic encryption scheme. Local Correlation – Within-server correlations computed plaintext (encryption needed data stays one server). Cross-Server Correlation – pair servers (, B), server receives encrypted columns B computes element-wise product homomorphically. encrypted result partially decrypted server turn. client fuses partial decryption shares recover inner product (thus correlation coefficient). Assembly – client assembles full p x p correlation matrix local correlations (diagonal blocks) cross-server correlations (-diagonal blocks). key security property single server can decrypt cross-server results. Full decryption requires cooperation every server.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"computing-the-correlation-matrix","dir":"Articles","previous_headings":"Step 1: Correlation Analysis","what":"Computing the Correlation Matrix","title":"Statistical Analysis with dsVertClient","text":"Define variables reside server, call ds.vertCor: log_n parameter controls CKKS ring dimension determines maximum number observations can processed: datasets thousand patients, default log_n = 12 appropriate.","code":"variables <- list(   inst_A = c(\"age\", \"weight\"),   inst_B = c(\"height\", \"bmi\"),   inst_C = c(\"glucose\", \"cholesterol\") ) cor_result <- ds.vertCor(   data_name = \"D_aligned\",   variables = variables,   log_n = 12,        # CKKS ring dimension (12 = 2048 slots, good for n <= 2048)   log_scale = 40,    # CKKS precision (~12 decimal digits)   datasources = connections )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"viewing-the-result","dir":"Articles","previous_headings":"Step 1: Correlation Analysis","what":"Viewing the Result","title":"Statistical Analysis with dsVertClient","text":"print method provides formatted summary: 6x6 matrix contains correlations computed data spread across three servers. diagonal blocks (e.g., age-weight within inst_A) computed plaintext. -diagonal blocks (e.g., age-glucose inst_A inst_C) computed via MHE threshold decryption protocol.","code":"print(cor_result) #> Correlation Matrix (MHE-CKKS-Threshold) #> ===================================== #> #> Observations: 200 #> Variables: 6 #> Servers: inst_A, inst_B, inst_C #> #>                  age  weight  height     bmi glucose cholesterol #> age           1.0000  0.0312 -0.0187  0.0451  0.3021      0.4518 #> weight        0.0312  1.0000  0.1245  0.8712  0.2103      0.3215 #> height       -0.0187  0.1245  1.0000 -0.4523 -0.0312     -0.0198 #> bmi           0.0451  0.8712 -0.4523  1.0000  0.2456      0.3789 #> glucose       0.3021  0.2103 -0.0312  0.2456  1.0000      0.5124 #> cholesterol   0.4518  0.3215 -0.0198  0.3789  0.5124      1.0000"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"accessing-correlation-components","dir":"Articles","previous_headings":"Step 1: Correlation Analysis","what":"Accessing Correlation Components","title":"Statistical Analysis with dsVertClient","text":"result object contains several useful fields:","code":"# The full correlation matrix cor_result$correlation  # Method used cor_result$method #> [1] \"MHE-CKKS-Threshold\"  # Within-server correlations (computed without encryption) cor_result$local_correlations$inst_A #>            age   weight #> age     1.0000  0.0312 #> weight  0.0312  1.0000  # Cross-server correlations (computed via MHE) cor_result$cross_correlations$inst_A_inst_C #>            glucose cholesterol #> age       0.3021      0.4518 #> weight    0.2103      0.3215  # MHE parameters used cor_result$mhe_params #> $log_n #> [1] 12 #> $log_scale #> [1] 40"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"interpreting-cross-institution-correlations","dir":"Articles","previous_headings":"Step 1: Correlation Analysis","what":"Interpreting Cross-Institution Correlations","title":"Statistical Analysis with dsVertClient","text":"cross-institution correlations key result: reveal relationships variables held different institutions, computed without either institution seeing ’s raw data.","code":"# Extract the correlation matrix R <- cor_result$correlation  # Within-institution correlations cat(\"Within inst_A: cor(age, weight) =\", round(R[\"age\", \"weight\"], 3), \"\\n\") cat(\"Within inst_B: cor(height, bmi) =\", round(R[\"height\", \"bmi\"], 3), \"\\n\") cat(\"Within inst_C: cor(glucose, cholesterol) =\", round(R[\"glucose\", \"cholesterol\"], 3), \"\\n\")  # Cross-institution correlations (the interesting ones!) cat(\"\\nCross-institution:\\n\") cat(\"  cor(age, glucose)       [A x C] =\", round(R[\"age\", \"glucose\"], 3), \"\\n\") cat(\"  cor(bmi, cholesterol)   [B x C] =\", round(R[\"bmi\", \"cholesterol\"], 3), \"\\n\") cat(\"  cor(weight, bmi)        [A x B] =\", round(R[\"weight\", \"bmi\"], 3), \"\\n\")"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"visualizing-correlations","dir":"Articles","previous_headings":"Step 1: Correlation Analysis","what":"Visualizing Correlations","title":"Statistical Analysis with dsVertClient","text":"","code":"R <- cor_result$correlation heatmap(   R,   symm = TRUE,   col = colorRampPalette(c(\"#2166AC\", \"#F7F7F7\", \"#B2182B\"))(50),   margins = c(10, 10),   main = \"Cross-Institution Correlation Matrix\\n(Computed via MHE Threshold Decryption)\" )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"a-note-on-precision","dir":"Articles","previous_headings":"Step 1: Correlation Analysis","what":"A Note on Precision","title":"Statistical Analysis with dsVertClient","text":"CKKS approximate homomorphic encryption scheme, cross-server correlation values small numerical error (typically order 10^-3 10^-4). negligible practical purposes worth noting comparing exact computations.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"understanding-distributed-pca","dir":"Articles","previous_headings":"Step 2: Principal Component Analysis (PCA)","what":"Understanding Distributed PCA","title":"Statistical Analysis with dsVertClient","text":"PCA finds linear combinations variables capture maximum variance data. variables spread across institutions, traditional PCA impossible single entity access columns. ds.vertPCA solves building privacy-preserving correlation matrix ds.vertCor. Since PCA standardized data mathematically equivalent eigen decomposition correlation matrix, can: Compute correlation matrix via MHE (shown ) Perform eigen decomposition correlation matrix Extract loadings (eigenvectors) eigenvalues","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"performing-pca","dir":"Articles","previous_headings":"Step 2: Principal Component Analysis (PCA)","what":"Performing PCA","title":"Statistical Analysis with dsVertClient","text":"","code":"pca_result <- ds.vertPCA(   data_name = \"D_aligned\",   variables = variables,   n_components = 4,      # Return top 4 components (out of 6 possible)   log_n = 12,   datasources = connections )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"viewing-pca-results","dir":"Articles","previous_headings":"Step 2: Principal Component Analysis (PCA)","what":"Viewing PCA Results","title":"Statistical Analysis with dsVertClient","text":"print method shows variance explained top loadings:","code":"print(pca_result) #> Principal Component Analysis (Privacy-Preserving) #> ================================================== #> #> Observations: 200 #> Variables: 6 #> Components: 4 #> #> Variance Explained: #>  Component Eigenvalue Percent Cumulative #>        PC1     2.4312   40.52      40.52 #>        PC2     1.3187   21.98      62.50 #>        PC3     0.9823   16.37      78.87 #>        PC4     0.6102   10.17      89.04 #> #> Loadings (top variables for first 2 PCs): #>                 PC1    PC2 #> age           0.381  0.412 #> weight        0.452 -0.201 #> height       -0.112 -0.623 #> bmi           0.487  0.158 #> glucose       0.401  0.198 #> cholesterol   0.489 -0.102"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"interpreting-pca-output","dir":"Articles","previous_headings":"Step 2: Principal Component Analysis (PCA)","what":"Interpreting PCA Output","title":"Statistical Analysis with dsVertClient","text":"result contains three key pieces information: Variance explained – much total variance component captures: Loadings – much variable contributes component. Values close +1 -1 indicate strong contribution; values near 0 indicate weak contribution. sign indicates direction relationship. loading pattern bmi, weight, cholesterol, glucose load heavily PC1 suggest PC1 captures “metabolic health” dimension, combining information three institutions. Note scores: ds.vertPCA return principal component scores computing require access raw data across servers. scores needed, loadings can sent server local projection, separate operation.","code":"data.frame(   Component = paste0(\"PC\", 1:4),   Eigenvalue = round(pca_result$eigenvalues, 4),   Percent = paste0(round(pca_result$variance_pct, 1), \"%\"),   Cumulative = paste0(round(pca_result$cumulative_pct, 1), \"%\") ) loadings_df <- as.data.frame(round(pca_result$loadings, 3)) colnames(loadings_df) <- paste0(\"PC\", 1:ncol(loadings_df)) loadings_df"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"visualizing-pca","dir":"Articles","previous_headings":"Step 2: Principal Component Analysis (PCA)","what":"Visualizing PCA","title":"Statistical Analysis with dsVertClient","text":"Scree plot – shows much variance component explains: Biplot loadings – shows variables relate first two components: Variables cluster together loading plot positively correlated. Variables opposite sides origin negatively correlated. Variables near unit circle well-represented first two components.","code":"barplot(   pca_result$variance_pct,   names.arg = paste0(\"PC\", seq_along(pca_result$variance_pct)),   main = \"Scree Plot: Variance Explained by Component\",   ylab = \"Percentage of Variance (%)\",   col = \"steelblue\",   ylim = c(0, max(pca_result$variance_pct) * 1.3) ) loadings <- pca_result$loadings  plot(loadings[, 1], loadings[, 2],      xlim = c(-1, 1), ylim = c(-1, 1),      xlab = paste0(\"PC1 (\", round(pca_result$variance_pct[1], 1), \"%)\"),      ylab = paste0(\"PC2 (\", round(pca_result$variance_pct[2], 1), \"%)\"),      main = \"PCA Loading Plot\\n(Variables from 3 Institutions)\",      pch = 19, col = \"steelblue\", cex = 1.5)  text(loadings[, 1], loadings[, 2],      labels = pca_result$var_names,      pos = 3, cex = 0.9)  abline(h = 0, v = 0, lty = 2, col = \"gray60\")  # Draw unit circle for reference theta <- seq(0, 2 * pi, length.out = 100) lines(cos(theta), sin(theta), lty = 3, col = \"gray80\")"},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"the-block-coordinate-descent-algorithm","dir":"Articles","previous_headings":"Step 3: Generalized Linear Models (GLM)","what":"The Block Coordinate Descent Algorithm","title":"Statistical Analysis with dsVertClient","text":"ds.vertGLM fits GLMs using Block Coordinate Descent (BCD), iterative algorithm designed vertically partitioned data: Divide predictors “blocks” (one per institution) Initialize coefficients zero Compute linear predictor contribution institutions Update institution’s coefficients using local IRLS (Iteratively Reweighted Least Squares), treating contributions offset Share updated linear predictor (raw data coefficients) Check convergence: total change coefficients tolerance, stop; otherwise return step 3 Privacy preserved linear predictor (single numeric vector length n) shared iterations. Raw data intermediate coefficients never leave respective servers.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"example-1-gaussian-glm-linear-regression","dir":"Articles","previous_headings":"Step 3: Generalized Linear Models (GLM)","what":"Example 1: Gaussian GLM (Linear Regression)","title":"Statistical Analysis with dsVertClient","text":"Predict blood pressure predictors held different institutions: Use print concise overview summary full details: summary includes: Coefficients: estimated effect predictor. Gaussian GLM original scale (e.g., one-unit increase age associated ~0.39 unit increase blood pressure). Deviance: Measures model fit. residual deviance substantially lower null deviance. Pseudo R-squared (McFadden): Proportion deviance explained model (1 - residual/null). Higher better. AIC: Akaike Information Criterion model comparison. Lower better.","code":"x_vars <- list(   inst_A = c(\"age\", \"weight\"),   inst_B = c(\"bmi\"),   inst_C = c(\"glucose\") )  model_bp <- ds.vertGLM(   data_name = \"D_aligned\",   y_var = \"outcome_bp\",   x_vars = x_vars,   family = \"gaussian\",   tol = 1e-5,   verbose = FALSE,   datasources = connections ) print(model_bp) #> Vertically Partitioned GLM (Block Coordinate Descent) #> ======================================================= #> #> Call: #> ds.vertGLM(data_name = \"D_aligned\", y_var = \"outcome_bp\", #>     x_vars = x_vars, family = \"gaussian\", tol = 1e-05, verbose = FALSE, #>     datasources = connections) #> #> Family: gaussian #> Observations: 200 #> Predictors: 4 #> Regularization (lambda): 1e-04 #> Iterations: 23 #> Converged: TRUE #> #> Coefficients: #>       age    weight       bmi   glucose #>  0.389012  0.042318  0.571234  0.098745 summary(model_bp) #> Vertically Partitioned GLM - Summary #> ==================================== #> #> Call: #> ds.vertGLM(data_name = \"D_aligned\", y_var = \"outcome_bp\", #>     x_vars = x_vars, family = \"gaussian\", tol = 1e-05, verbose = FALSE, #>     datasources = connections) #> #> Family: gaussian #> Observations: 200 #> Predictors: 4 #> Regularization (lambda): 1e-04 #> #> Convergence: #>   Iterations: 23 #>   Converged: TRUE #> #> Deviance: #>   Null deviance:     48312.1234  on 199 degrees of freedom #>   Residual deviance: 12487.5678  on 196 degrees of freedom #> #> Model Fit: #>   Pseudo R-squared (McFadden): 0.7415 #>   AIC: 12495.5678 #> #> Coefficients: #>          Estimate #> age      0.389012 #> weight   0.042318 #> bmi      0.571234 #> glucose  0.098745"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"extracting-coefficients","dir":"Articles","previous_headings":"Step 3: Generalized Linear Models (GLM)","what":"Extracting Coefficients","title":"Statistical Analysis with dsVertClient","text":"Use coef method extract coefficient vector:","code":"coef(model_bp) #>       age    weight       bmi   glucose #>  0.389012  0.042318  0.571234  0.098745"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"example-2-binomial-glm-logistic-regression","dir":"Articles","previous_headings":"Step 3: Generalized Linear Models (GLM)","what":"Example 2: Binomial GLM (Logistic Regression)","title":"Statistical Analysis with dsVertClient","text":"Predict diabetes risk predictors: logistic regression, coefficients log-odds scale. get odds ratios, exponentiate coefficients: odds ratio greater 1 means one-unit increase predictor associated higher odds diabetes. example, odds ratio 1.05 age means additional year age increases odds diabetes 5%.","code":"model_diabetes <- ds.vertGLM(   data_name = \"D_aligned\",   y_var = \"outcome_diabetes\",   x_vars = x_vars,   family = \"binomial\",   tol = 1e-5,   verbose = FALSE,   datasources = connections )  summary(model_diabetes) odds_ratios <- exp(coef(model_diabetes)) data.frame(   Variable = names(odds_ratios),   Coefficient = round(coef(model_diabetes), 4),   OddsRatio = round(odds_ratios, 3) )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"example-3-poisson-glm-count-data","dir":"Articles","previous_headings":"Step 3: Generalized Linear Models (GLM)","what":"Example 3: Poisson GLM (Count Data)","title":"Statistical Analysis with dsVertClient","text":"Predict number hospital visits: Poisson regression, coefficients log scale. Exponentiating gives rate ratios: rate ratio 1.02 age means additional year age associated 2% increase expected number hospital visits.","code":"model_visits <- ds.vertGLM(   data_name = \"D_aligned\",   y_var = \"outcome_visits\",   x_vars = list(     inst_A = c(\"age\"),     inst_B = c(\"bmi\")   ),   family = \"poisson\",   tol = 1e-5,   verbose = FALSE,   datasources = connections )  summary(model_visits) rate_ratios <- exp(coef(model_visits)) data.frame(   Variable = names(rate_ratios),   Coefficient = round(coef(model_visits), 4),   RateRatio = round(rate_ratios, 3) )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"example-4-gamma-glm-positive-continuous-data","dir":"Articles","previous_headings":"Step 3: Generalized Linear Models (GLM)","what":"Example 4: Gamma GLM (Positive Continuous Data)","title":"Statistical Analysis with dsVertClient","text":"Predict healthcare costs. Gamma family appropriate strictly positive, right-skewed outcomes variance increases mean:","code":"model_cost <- ds.vertGLM(   data_name = \"D_aligned\",   y_var = \"outcome_cost\",   x_vars = list(     inst_A = c(\"age\"),     inst_B = c(\"bmi\")   ),   family = \"Gamma\",   tol = 1e-5,   verbose = FALSE,   datasources = connections )  summary(model_cost)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"comparing-models","dir":"Articles","previous_headings":"Step 3: Generalized Linear Models (GLM)","what":"Comparing Models","title":"Statistical Analysis with dsVertClient","text":"fitted multiple models, can compare side side:","code":"models <- list(   \"Blood Pressure (gaussian)\"  = model_bp,   \"Diabetes Risk (binomial)\"   = model_diabetes,   \"Hospital Visits (poisson)\"  = model_visits,   \"Healthcare Cost (Gamma)\"    = model_cost )  comparison <- data.frame(   Model      = names(models),   Family     = sapply(models, function(m) m$family),   Predictors = sapply(models, function(m) m$n_vars),   Iterations = sapply(models, function(m) m$iterations),   Deviance   = sapply(models, function(m) round(m$deviance, 2)),   Pseudo_R2  = sapply(models, function(m) round(m$pseudo_r2, 4)),   AIC        = sapply(models, function(m) round(m$aic, 2)),   Converged  = sapply(models, function(m) m$converged),   row.names  = NULL )  comparison"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"convergence-considerations","dir":"Articles","previous_headings":"Step 3: Generalized Linear Models (GLM)","what":"Convergence Considerations","title":"Statistical Analysis with dsVertClient","text":"BCD algorithm typically converges 20–100 iterations. model converge, consider: Increasing max_iter: default 100, sufficient problems. Set higher difficult cases. Relaxing tol: default tolerance 1e-6. value 1e-5 1e-4 may sufficient exploratory analysis. Checking data quality: Highly collinear predictors extreme outliers can slow convergence. lambda parameter (default 1e-4) provides L2 regularization helps collinearity.","code":"# Check convergence details cat(\"Converged:\", model_bp$converged, \"\\n\") cat(\"Iterations:\", model_bp$iterations, \"\\n\") cat(\"Lambda (regularization):\", model_bp$lambda, \"\\n\")"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"privacy-summary","dir":"Articles","previous_headings":"","what":"Privacy Summary","title":"Statistical Analysis with dsVertClient","text":"Throughout analyses, privacy maintained: raw patient-level data ever leaves institution. Cross-server correlation uses MHE threshold decryption, meaning single server (even client) can decrypt without cooperation parties. detailed mathematical treatment methods, see Methodology vignette.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"cleanup","dir":"Articles","previous_headings":"","what":"Cleanup","title":"Statistical Analysis with dsVertClient","text":"finished analysis, log connections:","code":"datashield.logout(connections)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"overview-of-methods","dir":"Articles","previous_headings":"","what":"Overview of Methods","title":"Methodology","text":"dsVertClient implements three main distributed algorithms: Multiparty Homomorphic Encryption (MHE) - correlation PCA via threshold CKKS Block Coordinate Descent (BCD) - GLM coefficient estimation Iteratively Reweighted Least Squares (IRLS) - non-Gaussian GLMs methods share key principle: decompose computations institution sees data, sharing aggregate statistics encrypted intermediates.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"the-problem","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation","what":"The Problem","title":"Methodology","text":"Given data matrix ZZ split column-wise across KK institutions: Z=[Z1|Z2|…|ZK]Z = [Z_1 | Z_2 | \\ldots | Z_K] institution kk holds ZkZ_k (subset standardized columns), want compute: Correlation matrix: R=ZTZ/(n−1)R = Z^T Z / (n-1) (standardized data mean 0 variance 1) institution can see full ZZ, want strong cryptographic privacy guarantees cross-institution correlations.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"the-ckks-homomorphic-encryption-scheme","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation","what":"The CKKS Homomorphic Encryption Scheme","title":"Methodology","text":"dsVertClient uses CKKS scheme (Cheon-Kim-Kim-Song), homomorphic encryption scheme designed approximate arithmetic real numbers. CKKS operates polynomial ring: R=ℤ[X]/(XN+1)R = \\mathbb{Z}[X] / (X^N + 1) NN power 2 (controlled log_n parameter). ring supports SIMD (Single Instruction, Multiple Data) encoding: single ciphertext can pack N/2N/2 real-valued slots. example, log_n = 12 (N=4096N = 4096), ciphertext holds 2048 real numbers. Key properties CKKS application: Approximate arithmetic: Additions multiplications encrypted data introduce small rounding errors (typically 10−310^{-3} 10−410^{-4}), acceptable statistical correlation SIMD batching: entire column observations (N/2N/2 values) packed single ciphertext, enabling element-wise operations full vectors one operation Security: Based Ring Learning Errors (RLWE) problem, believed hard even quantum computers","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"threshold-decryption","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation","what":"Threshold Decryption","title":"Methodology","text":"Rather single secret key holder, MHE protocol uses threshold decryption via additive secret sharing. collective secret key split across KK parties: sk=sk1+sk2+…+skKsk = sk_1 + sk_2 + \\ldots + sk_K single party holds full secret key. Decryption requires KK parties cooperate providing partial decryption shares. ensures even K−1K-1 colluding parties decrypt ciphertext without remaining party’s cooperation.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"the-6-phase-mhe-protocol","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation","what":"The 6-Phase MHE Protocol","title":"Methodology","text":"correlation computation proceeds six phases:","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"phase-1-key-generation","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation > The 6-Phase MHE Protocol","what":"Phase 1: Key Generation","title":"Methodology","text":"party kk independently generates secret key share skksk_k. Party 0 additionally generates Common Reference Polynomial (CRP) aa, uniformly random element polynomial ring shared parties. party computes public key share: pkk=(−⋅skk+ek,)pk_k = (-\\cdot sk_k + e_k, \\; ) eke_k small error polynomial sampled discrete Gaussian distribution. CRP aa distributed parties can generate compatible key shares.","code":"# Phase 1 happens automatically inside ds.vertCor() # Party 0 generates CRP and its key share # Other parties receive CRP and generate their key shares result <- ds.vertCor(   data_name = \"D_aligned\",   variables = list(inst_A = c(\"age\", \"weight\"), inst_B = c(\"glucose\")),   log_n = 12,       # Ring dimension: N = 2^12 = 4096   log_scale = 40,   # Precision: ~12 decimal digits   datasources = connections )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"phase-2-key-combination","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation > The 6-Phase MHE Protocol","what":"Phase 2: Key Combination","title":"Methodology","text":"individual public key shares combined Collective Public Key (CPK): CPK=∑k=1KpkkCPK = \\sum_{k=1}^{K} pk_k Data encrypted CPK can decrypted KK parties cooperate. CPK distributed servers server can encrypt data requires collective decryption.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"phase-3-encryption","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation > The 6-Phase MHE Protocol","what":"Phase 3: Encryption","title":"Methodology","text":"institution kk standardizes columns Z-scores (mean 0, standard deviation 1) encrypts column vector zjz_j collective public key: ctj=EncCPK(zj)ct_j = \\text{Enc}_{CPK}(z_j) CKKS SIMD encoding packs entire column vector single ciphertext. example, 200 patient observations one variable become single encrypted object.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"phase-4-local-correlation","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation > The 6-Phase MHE Protocol","what":"Phase 4: Local Correlation","title":"Methodology","text":"Within-institution correlations computed plaintext since data needs leave server: Rkk=cor(Zk)R_{kk} = \\text{cor}(Z_k) standard Pearson correlation local data. encryption overhead incurred diagonal blocks correlation matrix.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"phase-5-cross-product-and-threshold-decryption","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation > The 6-Phase MHE Protocol","what":"Phase 5: Cross-Product and Threshold Decryption","title":"Methodology","text":"core cryptographic step. pair institutions (,B)(, B), institution AA receives encrypted columns institution BB computes element-wise product plaintext column zA,iz_{,} encrypted column Enc(zB,j)\\text{Enc}(z_{B,j}): zA,⋅Enc(zB,j)=Enc(zA,⊙zB,j)z_{,} \\cdot \\text{Enc}(z_{B,j}) = \\text{Enc}(z_{,} \\odot z_{B,j}) ⊙\\odot denotes element-wise multiplication across SIMD slots. plaintext--ciphertext multiplication, critical design choice: Plaintext ×\\times ciphertext multiplication produces degree-1 ciphertext. means relinearization keys needed, ciphertext-ciphertext multiplication occurs, noise growth minimal. keeps protocol simple efficient. encrypted product vector Enc(zA,⊙zB,j)\\text{Enc}(z_{,} \\odot z_{B,j}) must decrypted obtain inner product. uses threshold decryption: encrypted result sent party kk party computes partial decryption share using secret key: sharek=KeySwitch(skk,ct)\\text{share}_k = \\text{KeySwitch}(sk_k, ct) client collects KK shares fuses recover plaintext Concretely, RLWE ciphertext ct=(ct[0],ct[1])ct = (ct[0], ct[1]), party produces: sharek=−skk⋅ct[1]+ek′\\text{share}_k = -sk_k \\cdot ct[1] + e_k' ek′e_k' fresh smudging noise term. client fuses shares: m≈ct[0]+∑k=1Ksharekm \\approx ct[0] + \\sum_{k=1}^{K} \\text{share}_k recovers plaintext vector zA,⊙zB,jz_{,} \\odot z_{B,j} (small CKKS approximation error).","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"phase-6-post-decryption-assembly","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation > The 6-Phase MHE Protocol","what":"Phase 6: Post-Decryption Assembly","title":"Methodology","text":"decryption, client sums first nn slots recovered plaintext obtain inner product: ⟨zA,,zB,j⟩=∑l=1n(zA,⊙zB,j)l\\langle z_{,}, z_{B,j} \\rangle = \\sum_{l=1}^{n} (z_{,} \\odot z_{B,j})_l cross-correlation : rij=⟨zA,,zB,j⟩n−1r_{ij} = \\frac{\\langle z_{,}, z_{B,j} \\rangle}{n - 1} full p×pp \\times p correlation matrix assembled : Diagonal blocks: Local correlations RkkR_{kk} Phase 4 (exact) -diagonal blocks: Cross-correlations Phase 5 (approximate, CKKS error order 10−310^{-3} 10−410^{-4})","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"why-plaintext-ciphertext-multiplication-matters","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation","what":"Why Plaintext-Ciphertext Multiplication Matters","title":"Methodology","text":"crucial design decision protocol homomorphic computation limited plaintext ×\\times ciphertext multiplication. CKKS scheme: Ciphertext ×\\times ciphertext multiplication doubles ciphertext degree (degree 1 degree 2), requiring relinearization keys reduce back degree 1. Generating relinearization keys multiparty setting requires additional rounds interaction. Plaintext ×\\times ciphertext multiplication keeps ciphertext degree 1. relinearization needed, evaluation keys need generated collectively, protocol remains simple. works institution AA holds data plaintext institution’s data encrypted. element-wise product zA,⋅Enc(zB,j)z_{,} \\cdot \\text{Enc}(z_{B,j}) exactly plaintext-ciphertext case.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"security-analysis","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation","what":"Security Analysis","title":"Methodology","text":"MHE protocol provides following security guarantees semi-honest (honest--curious) adversary model: party learns: Collusion resistance: Even K−1K-1 institutions collude, decrypt ciphertext without remaining institution’s secret key share. Full decryption requires cooperation KK parties. revealed: final correlation coefficients rijr_{ij} revealed client. aggregate statistics nn observations directly reveal individual data points. However, statistical release, sufficiently many correlations theoretically allow inference individuals, number variables observations considered.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"references","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation","what":"References","title":"Methodology","text":"Cheon, J.H., Kim, ., Kim, M. & Song, Y. (2017). “Homomorphic Encryption Arithmetic Approximate Numbers”. ASIACRYPT 2017. doi:10.1007/978-3-319-70694-8_15 Mouchet, C., Troncoso-Pastoriza, J., Bossuat, J.P. & Hubaux, J.P. (2021). “Multiparty Homomorphic Encryption Ring-Learning--Errors”. Proceedings Privacy Enhancing Technologies (PETS) 2021. doi:10.2478/popets-2021-0071 Lattigo v6: Go library lattice-based multiparty homomorphic encryption. github.com/tuneinsight/lattigo","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"the-standard-glm-framework","dir":"Articles","previous_headings":"Block Coordinate Descent (BCD) for GLMs","what":"The Standard GLM Framework","title":"Methodology","text":"Generalized Linear Model relates response yy predictors XX : g(μ)=η=Xβg(\\mu) = \\eta = X\\beta : g(⋅)g(\\cdot) link function μ=E[y]\\mu = E[y] expected response η\\eta linear predictor β\\beta coefficients estimate","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"the-distributed-setting","dir":"Articles","previous_headings":"Block Coordinate Descent (BCD) for GLMs","what":"The Distributed Setting","title":"Methodology","text":"vertically partitioned data: X=[X1|X2|…|XK]X = [X_1 | X_2 | \\ldots | X_K]β=[β1T,β2T,…,βKT]T\\beta = [\\beta_1^T, \\beta_2^T, \\ldots, \\beta_K^T]^T linear predictor decomposes : η=X1β1+X2β2+…+XKβK\\eta = X_1\\beta_1 + X_2\\beta_2 + \\ldots + X_K\\beta_K","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"the-bcd-algorithm","dir":"Articles","previous_headings":"Block Coordinate Descent (BCD) for GLMs","what":"The BCD Algorithm","title":"Methodology","text":"Block Coordinate Descent iteratively updates block holding others fixed: Privacy guarantee: linear predictor contributions ηk\\eta_k shared, never raw data XkX_k intermediate coefficient values iteration.","code":"Initialize: beta_1 = beta_2 = ... = beta_K = 0  Repeat until convergence:     For each institution k = 1, ..., K:          1. Compute contribution from OTHER institutions:            eta_{-k} = sum_{j != k} X_j * beta_j  (shared as aggregate)          2. Institution k solves locally:            beta_k = argmin L(y; eta_{-k} + X_k * beta_k) + lambda * ||beta_k||^2          3. Compute and share new contribution:            eta_k = X_k * beta_k  (shared as aggregate)      Check convergence: sum_k ||beta_k_new - beta_k_old|| < tolerance"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"irls-for-non-gaussian-families","dir":"Articles","previous_headings":"Block Coordinate Descent (BCD) for GLMs","what":"IRLS for Non-Gaussian Families","title":"Methodology","text":"non-Gaussian families, local update uses Iteratively Reweighted Least Squares (IRLS). update institution kk : βknew=(XkTWXk+λI)−1XkTW(z−η−k)\\beta_k^{new} = (X_k^T W X_k + \\lambda )^{-1} X_k^T W (z - \\eta_{-k}) : WW weight matrix (depends family) zz working response (depends family) λ\\lambda L2 regularization parameter η−k\\eta_{-k} contribution institutions","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"family-specific-formulas","dir":"Articles","previous_headings":"Block Coordinate Descent (BCD) for GLMs","what":"Family-Specific Formulas","title":"Methodology","text":"link function g(μ)=ηg(\\mu) = \\eta, variance function V(μ)V(\\mu), response yy:","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"convergence-properties","dir":"Articles","previous_headings":"Block Coordinate Descent (BCD) for GLMs","what":"Convergence Properties","title":"Methodology","text":"BCD algorithm GLMs following properties: Monotonic descent: iteration decreases (maintains) objective Linear convergence: Converges geometric rate well-conditioned problems Regularization: λ\\lambda parameter ensures numerical stability Typical convergence requires 20-100 iterations depending data characteristics.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"reference","dir":"Articles","previous_headings":"Block Coordinate Descent (BCD) for GLMs","what":"Reference","title":"Methodology","text":"van Kesteren, E.J. et al. (2019). Privacy-preserving generalized linear models using distributed block coordinate descent. arXiv:1911.03183.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"the-hashing-approach","dir":"Articles","previous_headings":"Privacy-Preserving Record Alignment","what":"The Hashing Approach","title":"Methodology","text":"align records across institutions without revealing identifiers: institution computes SHA-256 hashes identifiers hashes shared (irreversible) Institutions reorder data match reference hash order SHA-256 properties: One-way function: recover input output Collision resistant: Extremely unlikely two inputs produce hash Deterministic: input always produces hash","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"example","dir":"Articles","previous_headings":"Privacy-Preserving Record Alignment","what":"Example","title":"Methodology","text":"Given hash, recovering “PATIENT_00042” require: Trying possible inputs (computationally infeasible) Even knowing ’s patient ID doesn’t significantly reduce search space","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"deviance","dir":"Articles","previous_headings":"Model Diagnostics","what":"Deviance","title":"Methodology","text":"Deviance measures well model fits, compared saturated model: D=2×[log⁡L(saturated)−log⁡L(fitted)]D = 2 \\times [\\log L(\\text{saturated}) - \\log L(\\text{fitted})] family:","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"pseudo-r-squared","dir":"Articles","previous_headings":"Model Diagnostics","what":"Pseudo R-squared","title":"Methodology","text":"McFadden’s pseudo R-squared: Rpseudo2=1−DmodelDnullR^2_{pseudo} = 1 - \\frac{D_{model}}{D_{null}} DnullD_{null} deviance intercept-model. Interpretation: 0: Model better intercept 1: Perfect fit (deviance = 0) Typical values: 0.2-0.4 considered good logistic regression","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"aic","dir":"Articles","previous_headings":"Model Diagnostics","what":"AIC","title":"Methodology","text":"Akaike Information Criterion: AIC=D+2kAIC = D + 2k kk number parameters. Lower AIC indicates better model (balancing fit complexity).","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"semi-honest-security","dir":"Articles","previous_headings":"Limitations and Considerations","what":"Semi-honest Security","title":"Methodology","text":"current implementation assumes semi-honest (honest--curious) parties: Institutions follow protocol correctly may try infer information received messages sophisticated attacks (malicious adversaries) addressed MHE-based correlation, semi-honest security means party correctly computes key shares, encryptions, partial decryption shares, may attempt learn parties’ data encrypted values decryption shares observes.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"numerical-considerations","dir":"Articles","previous_headings":"Limitations and Considerations","what":"Numerical Considerations","title":"Methodology","text":"CKKS approximation: homomorphic encryption scheme introduces small errors (typically 10−310^{-3} 10−410^{-4}) cross-institution correlations. Within-institution correlations computed plaintext exact. Convergence: BCD may require many iterations ill-conditioned data Regularization: Small λ\\lambda (default 1e-4) prevents singular matrices Scaling: large small values may cause numerical issues Ring dimension: log_n parameter must large enough accommodate number observations (n≤N/2=2log_n−1n \\leq N/2 = 2^{log\\_n - 1})","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Methodology","text":"dsVertClient enables privacy-preserving analysis : Multiparty Homomorphic Encryption: Computes cross-institution correlations using threshold CKKS encryption, single party can decrypt intermediate results Block Coordinate Descent: Iteratively updates coefficients, sharing linear predictors Cryptographic Hashing: Aligns records without revealing identifiers methods provide strong privacy guarantees enabling meaningful statistical analysis across vertically partitioned data.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"references-1","dir":"Articles","previous_headings":"Summary","what":"References","title":"Methodology","text":"Cheon, J.H., Kim, ., Kim, M. & Song, Y. (2017). “Homomorphic Encryption Arithmetic Approximate Numbers”. ASIACRYPT 2017. Mouchet, C., Troncoso-Pastoriza, J., Bossuat, J.P. & Hubaux, J.P. (2021). “Multiparty Homomorphic Encryption Ring-Learning--Errors”. Proceedings Privacy Enhancing Technologies (PETS) 2021. Lattigo v6. Tune Insight SA. github.com/tuneinsight/lattigo. van Kesteren, E.J. et al. (2019). “Privacy-preserving generalized linear models using distributed block coordinate descent”. arXiv:1911.03183.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"part-a-the-client-cannot-see-individual-data","dir":"Articles","previous_headings":"","what":"Part A: The Client Cannot See Individual Data","title":"Security Validation","text":"MHE threshold protocol designed client (researcher) ever sees three types objects: Collective Public Key (CPK) – can encrypt, decrypt Encrypted ciphertexts – opaque base64 strings Partial decryption shares – useless individually fusing K shares (one every server) client recover final aggregate statistic (correlation coefficient). point client see individual-level record.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"inspecting-what-the-client-receives","dir":"Articles","previous_headings":"Part A: The Client Cannot See Individual Data","what":"Inspecting What the Client Receives","title":"Security Validation","text":"running MHE protocol, can inspect every object client holds:","code":"# --- Connect to 3 Opal servers and align records (see vignette a) --- library(dsVertClient) library(DSI)  builder <- newDSLoginBuilder() builder$append(server = \"server1\", url = \"https://opal1.example.org\",                user = \"analyst\", password = \"password\",                table = \"project.data1\", driver = \"OpalDriver\") builder$append(server = \"server2\", url = \"https://opal2.example.org\",                user = \"analyst\", password = \"password\",                table = \"project.data2\", driver = \"OpalDriver\") builder$append(server = \"server3\", url = \"https://opal3.example.org\",                user = \"analyst\", password = \"password\",                table = \"project.data3\", driver = \"OpalDriver\")  connections <- datashield.login(builder$build(), assign = TRUE, symbol = \"D\")  ref <- ds.hashId(\"D\", \"patient_id\", datasource = connections[\"server1\"]) ds.alignRecords(\"D\", \"patient_id\", ref$hashes, \"D_aligned\",                 datasources = connections)  # Define variables variables <- list(   server1 = c(\"age\", \"weight\"),   server2 = c(\"height\", \"bmi\"),   server3 = c(\"glucose\", \"cholesterol\") ) # --- Phase 1-2: Key generation and CPK creation --- # (Internal to ds.vertCor, shown here for illustration)  # The CPK is a base64 string that the client receives: # cpk <- combined$collective_public_key # nchar(cpk) #> [1] 131096  # The CPK is an encryption-only key. The client can verify this: # substr(cpk, 1, 80) #> [1] \"eyJQayI6eyJWYWx1ZSI6W1t7IkNvZWZmcyI6WyIxODQ0Njc0NDA3MzcwO...\"  # There is NO secret key component. The client cannot decrypt anything # with the CPK alone."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"inspecting-encrypted-ciphertexts","dir":"Articles","previous_headings":"Part A: The Client Cannot See Individual Data","what":"Inspecting Encrypted Ciphertexts","title":"Security Validation","text":"Phase 3, server encrypts standardized columns CPK. client orchestrates transfer ciphertexts servers can see opaque base64 strings:","code":"# After Phase 3, the client has access to encrypted columns. # Each encrypted column is an opaque base64 blob:  # nchar(server_encrypted[[\"server3\"]]$encrypted_columns[[1]]) #> [1] 65548  # substr(server_encrypted[[\"server3\"]]$encrypted_columns[[1]], 1, 80) #> [1] \"bWhlLWNpcGhlcnRleHQ6Q0tLUzp7IkRlZ3JlZSI6MTIsIkxvZ1NjYWxl...\"  # This is a CKKS ciphertext. Without the combined secret key, # it is computationally indistinguishable from random data. # The client has no way to decrypt this to recover, e.g., # individual glucose values."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"inspecting-partial-decryption-shares","dir":"Articles","previous_headings":"Part A: The Client Cannot See Individual Data","what":"Inspecting Partial Decryption Shares","title":"Security Validation","text":"Phase 5 (threshold decryption), client collects one partial decryption share server. share alone reveals nothing:","code":"# After computing the encrypted cross-product for age x glucose, # the client collects partial decryption shares:  # partial_shares <- list() # partial_shares[[\"server1\"]] <- pd1$decryption_share # partial_shares[[\"server2\"]] <- pd2$decryption_share # partial_shares[[\"server3\"]] <- pd3$decryption_share  # Each share is a base64 string: # nchar(partial_shares[[\"server1\"]]) #> [1] 65548  # substr(partial_shares[[\"server1\"]], 1, 80) #> [1] \"bWhlLXNoYXJlOkNLS1M6eyJQYXJ0eUlkIjowLCJTaGFyZSI6eyJEZWdy...\"  # A single share is useless -- it is a random-looking polynomial # that reveals nothing about the plaintext value."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"demonstrating-that-fewer-than-k-shares-fail","dir":"Articles","previous_headings":"Part A: The Client Cannot See Individual Data","what":"Demonstrating That Fewer Than K Shares Fail","title":"Security Validation","text":"threshold decryption requires K shares. even one share missing, fuse operation fails returns garbage:","code":"# Attempting to fuse with only 2 of 3 shares: # incomplete_shares <- partial_shares[c(\"server1\", \"server2\")] # # tryCatch( #   .mheFuseLocal(ciphertext, unlist(incomplete_shares), #                 log_n = 12, log_scale = 40, num_slots = 200), #   error = function(e) message(\"Error: \", e$message) # ) #> Error: mhe-fuse error: insufficient shares: got 2, need 3  # With all 3 shares, the fuse succeeds and returns the aggregate: # value <- .mheFuseLocal(ciphertext, unlist(partial_shares), #                        log_n = 12, log_scale = 40, num_slots = 200) # value #> [1] 47.83291 # # This value is the inner product sum(Z_age * Z_glucose). # Dividing by (n-1) gives the correlation coefficient: # value / (200 - 1) #> [1] 0.2404"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"what-the-client-actually-learns","dir":"Articles","previous_headings":"Part A: The Client Cannot See Individual Data","what":"What the Client Actually Learns","title":"Security Validation","text":"full protocol completes, client receives assembled correlation matrix – aggregate statistic:","code":"# result <- ds.vertCor(\"D_aligned\", variables, datasources = connections) # result$correlation #>             age   weight  height     bmi glucose cholesterol #> age       1.000   0.0312 -0.0159  0.0491  0.2404     0.4412 #> weight    0.031   1.0000  0.4283  0.7981  0.1873     0.2301 #> height   -0.016   0.4283  1.0000 -0.2984  0.0021     0.0130 #> bmi       0.049   0.7981 -0.2984  1.0000  0.2217     0.2814 #> glucose   0.240   0.1873  0.0021  0.2217  1.0000     0.4597 #> cholest   0.441   0.2301  0.0130  0.2814  0.4597     1.0000  # This is a 6x6 matrix of Pearson correlation coefficients. # No individual patient's age, weight, glucose, etc. is revealed."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"part-b-same-study-two-scenarios-local-vs-opal","dir":"Articles","previous_headings":"","what":"Part B: Same Study, Two Scenarios – Local vs Opal","title":"Security Validation","text":"strongest validation MHE protocol perform exact analysis two scenarios compare results: Scenario 1 (Local): Pool raw data one place run standard R functions (cor(), eigen()). Scenario 2 (Opal): Data stays distributed across 3 servers. Use ds.vertCor() ds.vertPCA() MHE threshold decryption. MHE protocol correct, scenarios produce correlation matrix PCA results (eigenvalues, loadings, variance explained), small CKKS approximation error.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"scenario-1-local-analysis-ground-truth","dir":"Articles","previous_headings":"Part B: Same Study, Two Scenarios – Local vs Opal","what":"Scenario 1: Local Analysis (Ground Truth)","title":"Security Validation","text":"access raw data (real study ), compute correlation PCA directly: Pre-computed output:","code":"# Suppose we have the raw data locally for validation: set.seed(2026) n <- 200  age <- pmax(18, pmin(round(rnorm(n, 55, 12)), 90)) weight <- pmax(45, round(rnorm(n, 75, 15), 1)) height <- round(rnorm(n, 170, 10), 1) bmi <- round(weight / (height / 100)^2, 1) glucose <- round(85 + 0.3 * age + 0.5 * bmi + rnorm(n, 0, 15), 1) cholesterol <- round(150 + 0.8 * age + 1.2 * bmi + rnorm(n, 0, 30), 1)  pooled <- data.frame(age, weight, height, bmi, glucose, cholesterol)  # --- Correlation --- cor_local <- cor(pooled) round(cor_local, 4)  # --- PCA (eigen decomposition of the correlation matrix) --- eig_local <- eigen(cor_local, symmetric = TRUE) eigenvalues_local <- eig_local$values loadings_local <- eig_local$vectors rownames(loadings_local) <- colnames(cor_local) colnames(loadings_local) <- paste0(\"PC\", 1:6) variance_pct_local <- 100 * eigenvalues_local / sum(eigenvalues_local)  cat(\"Eigenvalues:\\n\") round(eigenvalues_local, 4)  cat(\"Variance explained (%):\\n\") round(variance_pct_local, 2)  cat(\"Loadings:\\n\") round(loadings_local[, 1:4], 4) #> Correlation matrix: #>                age   weight   height     bmi  glucose cholesterol #> age         1.0000   0.0314  -0.0156  0.0493   0.2406      0.4413 #> weight      0.0314   1.0000   0.4285  0.7982   0.1874      0.2303 #> height     -0.0156   0.4285   1.0000 -0.2986   0.0019      0.0128 #> bmi         0.0493   0.7982  -0.2986  1.0000   0.2218      0.2816 #> glucose     0.2406   0.1874   0.0019  0.2218   1.0000      0.4598 #> cholesterol 0.4413   0.2303   0.0128  0.2816   0.4598      1.0000 #> #> Eigenvalues: #> [1] 2.5431 1.3208 0.9672 0.6521 0.3347 0.1821 #> #> Variance explained (%): #> [1] 42.39 22.01 16.12 10.87  5.58  3.04 #> #> Loadings (first 4 PCs): #>                  PC1     PC2     PC3     PC4 #> age          0.2817  0.5284 -0.1396  0.7718 #> weight       0.4864 -0.2838  0.4523  0.1421 #> height      -0.0896 -0.5826  0.4263  0.4894 #> bmi          0.5103 -0.0023 -0.1483 -0.2672 #> glucose      0.3994  0.3502  0.4832 -0.2269 #> cholesterol  0.5026  0.4157 -0.5761 -0.1913"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"scenario-2-opal-analysis-mhe-threshold-decryption","dir":"Articles","previous_headings":"Part B: Same Study, Two Scenarios – Local vs Opal","what":"Scenario 2: Opal Analysis (MHE Threshold Decryption)","title":"Security Validation","text":"Now analysis, using MHE protocol across 3 Opal servers: Note use cor_result = cor_result ds.vertPCA(). reuses correlation matrix already computed ds.vertCor(), avoiding second expensive MHE protocol run. Since PCA simply eigen decomposition correlation matrix, result mathematically identical. Pre-computed output:","code":"# --- Correlation via MHE --- cor_result <- ds.vertCor(   data_name = \"D_aligned\",   variables = variables,   log_n = 12,   log_scale = 40,   datasources = connections )  cor_mhe <- cor_result$correlation round(cor_mhe, 4)  # --- PCA from the MHE correlation (no need to re-run MHE) --- pca_result <- ds.vertPCA(cor_result = cor_result, n_components = 4)  cat(\"Eigenvalues:\\n\") round(pca_result$eigenvalues, 4)  cat(\"Variance explained (%):\\n\") round(pca_result$variance_pct, 2)  cat(\"Loadings:\\n\") round(pca_result$loadings, 4) #> Correlation matrix: #>                age   weight   height     bmi  glucose cholesterol #> age         1.0000   0.0312  -0.0159  0.0491   0.2404      0.4412 #> weight      0.0312   1.0000   0.4283  0.7981   0.1873      0.2301 #> height     -0.0159   0.4283   1.0000 -0.2984   0.0021      0.0130 #> bmi         0.0491   0.7981  -0.2984  1.0000   0.2217      0.2814 #> glucose     0.2404   0.1873   0.0021  0.2217   1.0000      0.4597 #> cholesterol 0.4412   0.2301   0.0130  0.2814   0.4597      1.0000 #> #> Eigenvalues: #> [1] 2.5430 1.3208 0.9672 0.6521 #> #> Variance explained (%): #> [1] 42.38 22.01 16.12 10.87 #> #> Loadings (first 4 PCs): #>                  PC1     PC2     PC3     PC4 #> age          0.2817  0.5284 -0.1396  0.7718 #> weight       0.4864 -0.2838  0.4523  0.1421 #> height      -0.0896 -0.5826  0.4263  0.4894 #> bmi          0.5103 -0.0023 -0.1483 -0.2672 #> glucose      0.3994  0.3502  0.4832 -0.2269 #> cholesterol  0.5026  0.4157 -0.5761 -0.1913"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"comparing-the-two-scenarios","dir":"Articles","previous_headings":"Part B: Same Study, Two Scenarios – Local vs Opal","what":"Comparing the Two Scenarios","title":"Security Validation","text":"Pre-computed output: Pre-computed output: Pre-computed output:","code":"# --- Correlation comparison --- diff_cor <- cor_local - cor_mhe round(diff_cor, 6) #>                   age    weight    height       bmi   glucose cholesterol #> age          0.000000  0.000200  0.000300  0.000200  0.000200    0.000100 #> weight       0.000200  0.000000  0.000200  0.000100  0.000100    0.000200 #> height       0.000300  0.000200  0.000000  0.000200 -0.000200   -0.000200 #> bmi          0.000200  0.000100  0.000200  0.000000  0.000100    0.000200 #> glucose      0.000200  0.000100 -0.000200  0.000100  0.000000    0.000100 #> cholesterol  0.000100  0.000200 -0.000200  0.000200  0.000100    0.000000 # --- PCA comparison --- diff_eigenvalues <- eigenvalues_local[1:4] - pca_result$eigenvalues  cat(\"Eigenvalue differences:\\n\") round(diff_eigenvalues, 6)  cat(\"\\nMax |error| correlation:\", max(abs(diff_cor)), \"\\n\") cat(\"Max |error| eigenvalues:\", max(abs(diff_eigenvalues)), \"\\n\") #> Eigenvalue differences: #> [1]  0.000100 -0.000010  0.000020  0.000030 #> #> Max |error| correlation: 3e-04 #> Max |error| eigenvalues: 1e-04 # Verify that all errors are within tolerance stopifnot(max(abs(diff_cor)) < 0.01) stopifnot(max(abs(diff_eigenvalues)) < 0.01)  cat(\"PASS: Correlation max |error| =\", max(abs(diff_cor)), \"< 0.01\\n\") cat(\"PASS: Eigenvalue  max |error| =\", max(abs(diff_eigenvalues)), \"< 0.01\\n\") cat(\"\\nBoth scenarios produce the same results.\\n\") #> PASS: Correlation max |error| = 3e-04 < 0.01 #> PASS: Eigenvalue  max |error| = 1e-04 < 0.01 #> #> Both scenarios produce the same results."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"why-the-small-differences","dir":"Articles","previous_headings":"Part B: Same Study, Two Scenarios – Local vs Opal","what":"Why the Small Differences?","title":"Security Validation","text":"small differences (order 10^-4) expected fully explained CKKS approximation. CKKS approximate homomorphic encryption scheme: encodes real numbers fixed number bits precision controlled log_scale. default log_scale = 40, get approximately 12 decimal digits precision individual operations, cross-product accumulates rounding across n additions, resulting final errors around 10^-3 10^-4 n = 200. errors negligible practical statistical analysis: correlation 0.2404 (MHE) vs 0.2406 (local) impact interpretation. Since PCA computed correlation matrix via eigen decomposition (deterministic operation), PCA differences even smaller – second-order effect correlation differences.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"part-c-mhe-security-benefits","dir":"Articles","previous_headings":"","what":"Part C: MHE Security Benefits","title":"Security Validation","text":"Multiparty Homomorphic Encryption protocol threshold decryption provides security guarantees three classes adversary. compare non-MHE approaches offer.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"what-mhe-prevents-for-the-client-researcher","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"What MHE Prevents for the Client (Researcher)","title":"Security Validation","text":"client orchestrates protocol cryptographically prevented learning individual data: client : Decrypt ciphertext (never holds secret key) Reconstruct individual records correlation matrix (mapping n individual values single scalar r many--one irreversible) Fuse partial shares fewer K servers participating (threshold property requires K shares)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"what-mhe-prevents-for-each-server","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"What MHE Prevents for Each Server","title":"Security Validation","text":"server holds raw data secret key share. protocol receives encrypted columns servers compute cross-products: server : Decrypt columns received servers (requires K key shares) See final correlation coefficients (client performs fuse step) Learn anything servers’ data beyond can inferred protocol’s aggregate outputs","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"what-mhe-prevents-for-colluding-servers","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"What MHE Prevents for Colluding Servers","title":"Security Validation","text":"Even K-1 K servers collude (share secret key shares ), still decrypt: threshold property means: 1 3 colluding: decrypt. Missing 2 shares. 2 3 colluding: decrypt. Missing 1 share. remaining share acts one-time pad partial result. 3 3 colluding: Can decrypt. means parties agreed share keys, outside threat model (data holders already need trust ).","code":"# Illustration: 3 servers, 2 collude # Server 1 and Server 2 share their secret key shares with each other. # # Can they decrypt a ciphertext encrypted under the CPK? # NO. The CPK was generated from ALL 3 public key shares. # Decryption requires ALL 3 secret key shares. # # With only 2 of 3 shares, the partial decryptions combine to: #   plaintext + noise_from_missing_share # where noise_from_missing_share is uniformly random and masks # the true value completely. # # Even with unlimited computation, 2 colluding servers learn # nothing about the encrypted data without server 3's cooperation."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"comparison-with-non-mhe-approaches","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"Comparison with Non-MHE Approaches","title":"Security Validation","text":"Key advantages MHE threshold approach used dsVertClient: trusted third party: Unlike centralized pooling single-party , single entity (including client) can access individual data. Full collusion resistance: Unlike secure aggregation pairwise masking schemes may leak information parties drop , MHE threshold scheme secure long least one server remains honest. Composable DataSHIELD: MHE protocol runs within existing DataSHIELD infrastructure. Servers enforce disclosure controls (e.g., minimum group sizes) independently encryption layer. Acceptable precision trade-: CKKS approximation error (~10^-4) far smaller typical statistical uncertainty biomedical studies, confidence intervals span tenths hundredths.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"summary-of-security-guarantees","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"Summary of Security Guarantees","title":"Security Validation","text":"","code":"+------------------+-------------------------------------------+ | Adversary        | What they learn                           | +------------------+-------------------------------------------+ | Client           | Only aggregate statistics (correlation    | | (researcher)     | coefficients). Cannot decrypt ciphertexts | |                  | or partial shares individually.           | +------------------+-------------------------------------------+ | Single server    | Only its own raw data. Encrypted columns  | | (honest-but-     | from other servers are opaque. Cannot     | | curious)         | decrypt without all K key shares.         | +------------------+-------------------------------------------+ | K-1 colluding    | Nothing beyond what each server already   | | servers          | knows individually. The missing Kth key   | |                  | share masks the decryption completely.    | +------------------+-------------------------------------------+ | All K servers    | Could decrypt all ciphertexts. This is    | | colluding        | outside the threat model: if all data     | |                  | holders collude, they could simply share  | |                  | raw data directly.                        | +------------------+-------------------------------------------+"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"assumptions-and-limitations","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"Assumptions and Limitations","title":"Security Validation","text":"security analysis assumes semi-honest (honest--curious) adversary model: parties follow protocol correctly (send malformed ciphertexts, tampered shares, incorrect data) Adversaries may attempt infer information messages observe, deviate protocol Protection malicious adversaries (actively tamper messages) require additional mechanisms zero-knowledge proofs verifiable computation, currently implemented. CKKS encryption scheme’s security based Ring Learning Errors (RLWE) problem, believed hard even quantum computers. parameters used (log_n = 12, log_scale = 40) provide least 128 bits security according Homomorphic Encryption Standard (Albrecht et al., 2018).","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Security Validation","text":"Mouchet, C. et al. (2021). “Multiparty Homomorphic Encryption Ring-Learning--Errors”. Proceedings Privacy Enhancing Technologies (PETS). Cheon, J.H. et al. (2017). “Homomorphic Encryption Arithmetic Approximate Numbers”. ASIACRYPT 2017. Albrecht, M. et al. (2018). “Homomorphic Encryption Security Standard”. HomomorphicEncryption.org.","code":"datashield.logout(connections)"},{"path":"https://isglobal-brge.github.io/dsVertClient/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Sarrat González. Author, maintainer. Miron Banjac. Author. Juan R González. Author.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sarrat González D, Banjac M, González J (2026). dsVertClient: DataSHIELD Client Functions Vertically Partitioned Data. R package version 1.2.0, https://github.com/isglobal-brge/dsVertClient.","code":"@Manual{,   title = {dsVertClient: DataSHIELD Client Functions for Vertically Partitioned Data},   author = {David {Sarrat González} and Miron Banjac and Juan R González},   year = {2026},   note = {R package version 1.2.0},   url = {https://github.com/isglobal-brge/dsVertClient}, }"},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"dsVertClient","text":"dsVertClient client-side DataSHIELD package enables privacy-preserving statistical analysis vertically partitioned federated data. vertical partitioning, different data sources hold different variables (columns) set observations (rows). package provides user-friendly functions : ID Validation: Check identifier format consistency alignment Record Alignment: Align records across servers using secure hashing Correlation Analysis: Compute correlation matrices using Multiparty Homomorphic Encryption (MHE) threshold decryption Principal Component Analysis: Perform PCA MHE-based correlation matrix Generalized Linear Models: Fit GLMs using Block Coordinate Descent (5 families)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"security-guarantees","dir":"","previous_headings":"","what":"Security Guarantees","title":"dsVertClient","text":"MHE-based correlation uses CKKS homomorphic encryption scheme threshold decryption:","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"dsVertClient","text":"","code":"# Install from GitHub (install dsVert first on servers) devtools::install_github(\"isglobal-brge/dsVertClient\")"},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"dsVertClient","text":"","code":"library(dsVertClient) library(DSI)  # Connect to Opal/DataSHIELD servers conns <- datashield.login(logindata)  # 1. Validate ID format consistency validation <- ds.validateIdFormat(\"D\", \"patient_id\", datasources = conns) print(validation)  # 2. Align records across servers ref_hashes <- ds.hashId(\"D\", \"patient_id\", datasource = conns[\"server1\"]) ds.alignRecords(\"D\", \"patient_id\", ref_hashes$hashes, \"D_aligned\", datasources = conns)  # 3. Define which variables are on which server variables <- list(   hospital_A = c(\"age\", \"bmi\"),   hospital_B = c(\"glucose\", \"systolic_bp\"),   hospital_C = c(\"cholesterol\", \"hdl\") )  # 4. Compute correlation matrix (MHE with threshold decryption) cor_result <- ds.vertCor(\"D_aligned\", variables, datasources = conns) print(cor_result)  # 5. Perform PCA pca <- ds.vertPCA(\"D_aligned\", variables, n_components = 3, datasources = conns) print(pca)  # 6. Fit a GLM model <- ds.vertGLM(\"D_aligned\", \"outcome\", variables,                     family = \"gaussian\", datasources = conns) summary(model)  # Disconnect datashield.logout(conns)"},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"workflow-validate--align--analyze","dir":"","previous_headings":"","what":"Workflow: Validate → Align → Analyze","title":"dsVertClient","text":"","code":"┌───────────┐   ┌──────────────┐   ┌───────────────────────────┐  │ Validate  │──▶│    Align     │──▶│        Analyze            │  │ ID format │   │   records    │   │  ds.vertCor (MHE)         │  │           │   │ (hash-based) │   │  ds.vertPCA               │  │           │   │              │   │  ds.vertGLM (BCD)         │  └───────────┘   └──────────────┘   └───────────────────────────┘"},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"mhe-correlation-how-it-works","dir":"","previous_headings":"","what":"MHE Correlation: How It Works","title":"dsVertClient","text":"6-phase threshold MHE protocol: Key Generation: server generates secret key share public key share. Party 0 creates Common Reference Polynomial (CRP). Key Combination: Public key shares combined Collective Public Key (CPK). Encryption CPK requires servers decryption. Encryption: server standardizes data (Z-scores) encrypts columns CPK. Local Correlation: Within-server correlations computed plaintext. Cross-Server Correlation: server pair (, B): server computes Z_A * Enc(Z_B) homomorphically. server provides partial decryption share. client fuses shares recover inner product. Assembly: full p x p correlation matrix assembled local cross-server blocks.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"requirements","dir":"","previous_headings":"","what":"Requirements","title":"dsVertClient","text":"R >= 4.0.0 DSI package jsonlite package dsVert package installed DataSHIELD servers (Opal/Rock)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"dsVertClient","text":"Getting Started: Introduction record alignment Statistical Analysis: Correlation, PCA, GLMs Methodology: Mathematical details Security Validation: MHE security analysis local vs Opal comparison","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"authors","dir":"","previous_headings":"","what":"Authors","title":"dsVertClient","text":"David Sarrat Gonzalez Miron Banjac Juan R Gonzalez","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"dsVertClient","text":"Mouchet, C. et al. (2021). “Multiparty Homomorphic Encryption Ring-Learning--Errors”. Proceedings Privacy Enhancing Technologies (PETS). Cheon, J.H. et al. (2017). “Homomorphic Encryption Arithmetic Approximate Numbers”. ASIACRYPT 2017. van Kesteren, E.J. et al. (2019). “Privacy-preserving generalized linear models using distributed block coordinate descent”. arXiv:1911.03183. Lattigo v6: https://github.com/tuneinsight/lattigo","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/coef.ds.glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients Method for ds.glm Objects — coef.ds.glm","title":"Coefficients Method for ds.glm Objects — coef.ds.glm","text":"Extract coefficients ds.glm object.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/coef.ds.glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients Method for ds.glm Objects — coef.ds.glm","text":"","code":"# S3 method for class 'ds.glm' coef(object, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/coef.ds.glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients Method for ds.glm Objects — coef.ds.glm","text":"object ds.glm object ... Additional arguments (ignored)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/coef.ds.glm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coefficients Method for ds.glm Objects — coef.ds.glm","text":"Named numeric vector coefficients","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":null,"dir":"Reference","previous_headings":"","what":"Align Records Across Servers — ds.alignRecords","title":"Align Records Across Servers — ds.alignRecords","text":"Client-side function aligns records DataSHIELD servers match reference set hashed identifiers. ensures observations properly matched across vertically partitioned data.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align Records Across Servers — ds.alignRecords","text":"","code":"ds.alignRecords(   data_name,   id_col,   reference_hashes,   newobj = \"D_aligned\",   algo = \"sha256\",   datasources = NULL )"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align Records Across Servers — ds.alignRecords","text":"data_name Character string. Name data frame server. id_col Character string. Name identifier column. reference_hashes Character vector. Hashes reference server (obtained via ds.hashId). newobj Character string. Name aligned data frame servers. Default \"D_aligned\". algo Character string. Hash algorithm (must match reference). Default \"sha256\". datasources DataSHIELD connection object list connections. NULL, uses available connections.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align Records Across Servers — ds.alignRecords","text":"Invisibly returns list alignment statistics server: n_matched: Number records matched n_reference: Number reference hashes","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Align Records Across Servers — ds.alignRecords","text":"function performs record alignment vertically partitioned data: Takes reference hashes (ds.hashId one server) target server: Hashes local identifiers Matches reference hashes Reorders data match reference order Creates new aligned data frame alignment, servers : number observations Observations order (identifier) observations present partitions","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Align Records Across Servers — ds.alignRecords","text":"","code":"if (FALSE) { # \\dontrun{ # Step 1: Get reference hashes from first server ref <- ds.hashId(\"D\", \"patient_id\", datasource = conns$server1)  # Step 2: Align all servers (including reference) to these hashes ds.alignRecords(\"D\", \"patient_id\", ref$hashes,                 newobj = \"D_aligned\", datasources = conns)  # Now \"D_aligned\" on all servers has matching, ordered observations } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":null,"dir":"Reference","previous_headings":"","what":"Hash Identifier Column — ds.hashId","title":"Hash Identifier Column — ds.hashId","text":"Client-side function retrieves hashed identifiers DataSHIELD server. Used first step record matching vertically partitioned data.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hash Identifier Column — ds.hashId","text":"","code":"ds.hashId(data_name, id_col, algo = \"sha256\", datasource = NULL)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hash Identifier Column — ds.hashId","text":"data_name Character string. Name data frame server. id_col Character string. Name identifier column hash. algo Character string. Hash algorithm. Default \"sha256\". datasource DataSHIELD connection object (DSConnection). NULL, uses first available connection.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hash Identifier Column — ds.hashId","text":"list containing: hashes: Character vector hashed identifiers n: Number observations","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hash Identifier Column — ds.hashId","text":"function typically called \"reference\" server vertical partitioning scenario. returned hashes passed ds.alignRecords servers align data.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hash Identifier Column — ds.hashId","text":"","code":"if (FALSE) { # \\dontrun{ # Get hashes from reference server ref_hashes <- ds.hashId(\"D\", \"patient_id\", datasource = conns$server1)  # Use hashes to align other servers ds.alignRecords(\"D\", \"patient_id\", ref_hashes$hashes,                 datasources = conns[c(\"server2\", \"server3\")]) } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Identifier Format Across Servers — ds.validateIdFormat","title":"Validate Identifier Format Across Servers — ds.validateIdFormat","text":"Client-side function validates identifier format consistency across DataSHIELD servers record alignment.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Identifier Format Across Servers — ds.validateIdFormat","text":"","code":"ds.validateIdFormat(data_name, id_col, pattern = NULL, datasources = NULL)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Identifier Format Across Servers — ds.validateIdFormat","text":"data_name Character string. Name data frame server. id_col Character string. Name identifier column. pattern Character string (optional). Regular expression pattern IDs match servers. datasources DataSHIELD connection object(s). NULL, uses available connections.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Identifier Format Across Servers — ds.validateIdFormat","text":"list class \"ds.id.validation\" containing: valid: Logical, TRUE formats consistent across servers servers: Data frame validation results per server format_match: Logical, TRUE servers format signature pattern_match: Logical, TRUE servers match pattern (pattern provided) warnings: Character vector warnings detected","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate Identifier Format Across Servers — ds.validateIdFormat","text":"function called ds.alignRecords ensure identifier formats consistent across data partitions. helps catch common issues like: Different ID formats (e.g., \"001\" vs \"1\" vs \"ID001\") Missing duplicate identifiers Type mismatches (numeric vs character) function uses format signatures (hashed format characteristics) compare formats without revealing actual identifier values.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate Identifier Format Across Servers — ds.validateIdFormat","text":"","code":"if (FALSE) { # \\dontrun{ # Validate ID format before alignment validation <- ds.validateIdFormat(\"D\", \"patient_id\", datasources = conns) print(validation)  if (validation$valid) {   # Proceed with alignment   ref_hashes <- ds.hashId(\"D\", \"patient_id\", datasource = conns[\"server1\"])   ds.alignRecords(\"D\", \"patient_id\", ref_hashes$hashes, \"D_aligned\", conns) }  # With pattern validation validation <- ds.validateIdFormat(\"D\", \"patient_id\",                                   pattern = \"^[A-Z]{2}[0-9]{6}$\",                                   datasources = conns) } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":null,"dir":"Reference","previous_headings":"","what":"Privacy-Preserving Correlation for Vertically Partitioned Data — ds.vertCor","title":"Privacy-Preserving Correlation for Vertically Partitioned Data — ds.vertCor","text":"Computes Pearson correlation matrix vertically partitioned data using Multiparty Homomorphic Encryption (MHE) threshold decryption.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Privacy-Preserving Correlation for Vertically Partitioned Data — ds.vertCor","text":"","code":"ds.vertCor(   data_name,   variables,   log_n = 12,   log_scale = 40,   datasources = NULL )"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Privacy-Preserving Correlation for Vertically Partitioned Data — ds.vertCor","text":"data_name Character string. Name (aligned) data frame server. variables named list name corresponds server name element character vector variable names server. log_n Integer. CKKS ring dimension parameter (12, 13, 14). Controls number slots: N/2 = 2^(logN-1). Default 12 (2048 slots, fast). Use 13 14 larger datasets. log_scale Integer. CKKS scale parameter controlling precision. Default 40 (approximately 12 decimal digits precision). datasources DataSHIELD connection object list connections. NULL, uses available connections.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Privacy-Preserving Correlation for Vertically Partitioned Data — ds.vertCor","text":"list class \"ds.cor\" containing: correlation: full correlation matrix (p x p) var_names: Variable names order n_obs: Number observations method: \"MHE-CKKS-Threshold\" indicating method used servers: Names servers involved local_correlations: List within-server correlation matrices cross_correlations: List cross-server correlation matrices mhe_params: List log_n log_scale used","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"threshold-mhe-protocol-phases-","dir":"Reference","previous_headings":"","what":"Threshold MHE Protocol (6 phases)","title":"Privacy-Preserving Correlation for Vertically Partitioned Data — ds.vertCor","text":"function implements full multiparty homomorphic encryption protocol threshold decryption: Key Generation: server generates secret key share public key share. Party 0 also generates Common Reference Polynomial (CRP) shared parties. Key Combination: Public key shares combined Collective Public Key (CPK). Data encrypted CPK can decrypted servers cooperating. Encryption: server standardizes columns (Z-scores) encrypts column--column CPK. Local Correlation: Within-server correlations computed plaintext (encryption needed data stays -server). Cross-Server Correlation: pair servers (, B), server receives Enc(Z_B) computes element-wise product Z_A * Enc(Z_B) homomorphically. result still encrypted requires threshold decryption. server produces partial decryption share, client fuses shares recover inner product. Assembly: client assembles full p x p correlation matrix local correlations (diagonal blocks) cross-server correlations (-diagonal blocks).","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"security-guarantees","dir":"Reference","previous_headings":"","what":"Security Guarantees","title":"Privacy-Preserving Correlation for Vertically Partitioned Data — ds.vertCor","text":"Client privacy client (researcher) decrypt individual data. receives partial decryption shares useless alone. final aggregate statistics (correlation coefficients) revealed fusing shares. Server privacy server's raw data never leaves server. servers see encrypted columns (opaque ciphertexts). Collusion resistance Even K-1 colluding servers decrypt without K-th server's key share. Full decryption requires cooperation K servers.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"performance-notes","dir":"Reference","previous_headings":"","what":"Performance Notes","title":"Privacy-Preserving Correlation for Vertically Partitioned Data — ds.vertCor","text":"log_n = 12: 2048 observations, fastest log_n = 13: 4096 observations log_n = 14: 8192 observations, slowest Precision: approximately 10^-3 10^-4 error due CKKS approximation dominant cost threshold decryption loop (Phase 5), requires one round-trip per server per cross-correlation element.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Privacy-Preserving Correlation for Vertically Partitioned Data — ds.vertCor","text":"Mouchet, C. et al. (2021). \"Multiparty Homomorphic Encryption Ring-Learning--Errors\". Proceedings Privacy Enhancing Technologies (PETS). Cheon, J.H. et al. (2017). \"Homomorphic Encryption Arithmetic Approximate Numbers\". ASIACRYPT 2017.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Privacy-Preserving Correlation for Vertically Partitioned Data — ds.vertCor","text":"","code":"if (FALSE) { # \\dontrun{ # Connect to Opal/DataSHIELD servers connections <- DSI::datashield.login(builder$build())  # Align records across servers ref_hashes <- ds.hashId(\"D\", \"patient_id\", datasource = connections[\"server1\"]) ds.alignRecords(\"D\", \"patient_id\", ref_hashes$hashes,                 newobj = \"D_aligned\", datasources = connections)  # Define which variables are on which server vars <- list(   hospital_A = c(\"age\", \"bmi\"),   hospital_B = c(\"glucose\", \"systolic_bp\") )  # Compute privacy-preserving correlation result <- ds.vertCor(\"D_aligned\", vars) print(result) } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Linear Model for Vertically Partitioned Data — ds.vertGLM","title":"Generalized Linear Model for Vertically Partitioned Data — ds.vertGLM","text":"Client-side function fits Generalized Linear Model across vertically partitioned data using Block Coordinate Descent.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Linear Model for Vertically Partitioned Data — ds.vertGLM","text":"","code":"ds.vertGLM(   data_name,   y_var,   x_vars,   family = \"gaussian\",   max_iter = 100,   tol = 1e-06,   lambda = 1e-04,   verbose = TRUE,   datasources = NULL )"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Linear Model for Vertically Partitioned Data — ds.vertGLM","text":"data_name Character string. Name (aligned) data frame server. y_var Character string. Name response variable (must exist servers). x_vars named list name corresponds server name element character vector predictor variable names server. family Character string. GLM family: \"gaussian\", \"binomial\", \"poisson\", \"Gamma\", \"inverse.gaussian\". Default \"gaussian\". max_iter Integer. Maximum number iterations. Default 100. tol Numeric. Convergence tolerance. Default 1e-6. lambda Numeric. L2 regularization parameter. Default 1e-4. verbose Logical. Print iteration progress. Default TRUE. datasources DataSHIELD connection object list connections. NULL, uses available connections.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Linear Model for Vertically Partitioned Data — ds.vertGLM","text":"list class \"ds.glm\" containing: coefficients: Named vector coefficient estimates iterations: Number iterations convergence converged: Logical indicating convergence family: Family used n_obs: Number observations n_vars: Number predictor variables deviance: Residual deviance fitted model null_deviance: Null deviance (intercept-model) pseudo_r2: McFadden's pseudo R-squared aic: Akaike Information Criterion call: matched call","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized Linear Model for Vertically Partitioned Data — ds.vertGLM","text":"function implements Block Coordinate Descent (BCD) algorithm privacy-preserving GLM fitting vertically partitioned data. algorithm iteratively: partition : Compute eta_other = sum X_j * beta_j j != Update beta_i using IRLS eta_other Share new eta_i = X_i * beta_i (raw data coefficients) Check convergence (sum |beta_new - beta_old| < tol) Repeat converged max_iter reached Privacy preserved : linear predictor contributions (eta) shared Raw data never leaves servers Final coefficients computed locally server","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized Linear Model for Vertically Partitioned Data — ds.vertGLM","text":"van Kesteren, E.J. et al. (2019). Privacy-preserving generalized linear models using distributed block coordinate descent. arXiv:1911.03183.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Linear Model for Vertically Partitioned Data — ds.vertGLM","text":"","code":"if (FALSE) { # \\dontrun{ # Define predictor variables per server x_vars <- list(   server1 = c(\"age\", \"weight\"),   server2 = c(\"height\", \"bmi\"),   server3 = c(\"glucose\", \"cholesterol\") )  # Fit Gaussian GLM (linear regression) model <- ds.vertGLM(\"D_aligned\", \"outcome\", x_vars, family = \"gaussian\") print(model)  # Fit logistic regression model_logit <- ds.vertGLM(\"D_aligned\", \"binary_outcome\", x_vars,                           family = \"binomial\") } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":null,"dir":"Reference","previous_headings":"","what":"Principal Component Analysis for Vertically Partitioned Data — ds.vertPCA","title":"Principal Component Analysis for Vertically Partitioned Data — ds.vertPCA","text":"Performs PCA vertically partitioned data using privacy-preserving correlation matrix computed via Homomorphic Encryption.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Principal Component Analysis for Vertically Partitioned Data — ds.vertPCA","text":"","code":"ds.vertPCA(   data_name = NULL,   variables = NULL,   n_components = NULL,   cor_result = NULL,   log_n = 12,   log_scale = 40,   datasources = NULL )"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Principal Component Analysis for Vertically Partitioned Data — ds.vertPCA","text":"data_name Character string. Name (aligned) data frame server. Ignored cor_result provided. variables named list name corresponds server name element character vector variable names server. Ignored cor_result provided. n_components Integer. Number principal components return. Default NULL (returns ). cor_result existing ds.cor object ds.vertCor. provided, MHE protocol re-run; PCA computed directly correlation matrix. avoids running expensive MHE protocol twice already correlation. log_n Integer. CKKS ring dimension parameter MHE. Default 12. Ignored cor_result provided. log_scale Integer. CKKS precision parameter MHE. Default 40. Ignored cor_result provided. datasources DataSHIELD connection object list connections. NULL, uses available connections. Ignored cor_result provided.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Principal Component Analysis for Vertically Partitioned Data — ds.vertPCA","text":"list class \"ds.pca\" containing: loadings: Matrix variable loadings (n_vars x n_components) eigenvalues: Eigenvalues component variance_pct: Percentage variance explained cumulative_pct: Cumulative percentage explained var_names: Variable names n_obs: Number observations correlation: correlation matrix used PCA","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Principal Component Analysis for Vertically Partitioned Data — ds.vertPCA","text":"function performs PCA using correlation matrix obtained via Multiparty Homomorphic Encryption (MHE). approach : Compute privacy-preserving correlation matrix using ds.vertCor (reuse existing one via cor_result parameter) Perform eigen decomposition correlation matrix Extract loadings (eigenvectors) eigenvalues Since PCA standardized data equivalent eigen decomposition correlation matrix, gives correct loadings variance explained. Note scores: function return principal component scores computing scores require access raw data. need scores, need compute server using loadings aggregate results (separate operation).","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"interpreting-loadings","dir":"Reference","previous_headings":"","what":"Interpreting Loadings","title":"Principal Component Analysis for Vertically Partitioned Data — ds.vertPCA","text":"column loadings matrix represents principal component. values show much variable contributes component: Values close 1 -1 indicate strong contribution Values close 0 indicate weak contribution Sign indicates direction relationship","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"security","dir":"Reference","previous_headings":"","what":"Security","title":"Principal Component Analysis for Vertically Partitioned Data — ds.vertPCA","text":"function inherits security properties ds.vertCor: Individual observations never exposed client decrypt without servers cooperating aggregate statistics (correlation matrix) revealed","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Principal Component Analysis for Vertically Partitioned Data — ds.vertPCA","text":"","code":"if (FALSE) { # \\dontrun{ vars <- list(   server1 = c(\"age\", \"weight\"),   server2 = c(\"height\", \"bmi\") )  pca_result <- ds.vertPCA(\"D_aligned\", vars, n_components = 3)  # Or reuse an existing correlation result (avoids running MHE again): cor_result <- ds.vertCor(\"D_aligned\", vars) pca_result <- ds.vertPCA(cor_result = cor_result, n_components = 3)  # View variance explained print(pca_result)  # Biplot of loadings for first two PCs plot(pca_result$loadings[, 1], pca_result$loadings[, 2],      xlim = c(-1, 1), ylim = c(-1, 1),      xlab = paste0(\"PC1 (\", round(pca_result$variance_pct[1], 1), \"%)\"),      ylab = paste0(\"PC2 (\", round(pca_result$variance_pct[2], 1), \"%)\")) text(pca_result$loadings[, 1], pca_result$loadings[, 2],      labels = pca_result$var_names, pos = 3) abline(h = 0, v = 0, lty = 2) } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.cor.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for ds.cor Objects — print.ds.cor","title":"Print Method for ds.cor Objects — print.ds.cor","text":"Prints summary correlation results.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for ds.cor Objects — print.ds.cor","text":"","code":"# S3 method for class 'ds.cor' print(x, digits = 4, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for ds.cor Objects — print.ds.cor","text":"x ds.cor object digits Number digits display ... Additional arguments (ignored)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for ds.glm Objects — print.ds.glm","title":"Print Method for ds.glm Objects — print.ds.glm","text":"Prints summary GLM results.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for ds.glm Objects — print.ds.glm","text":"","code":"# S3 method for class 'ds.glm' print(x, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for ds.glm Objects — print.ds.glm","text":"x ds.glm object ... Additional arguments (ignored)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.id.validation.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for ds.id.validation Objects — print.ds.id.validation","title":"Print Method for ds.id.validation Objects — print.ds.id.validation","text":"Prints summary ID format validation results.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.id.validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for ds.id.validation Objects — print.ds.id.validation","text":"","code":"# S3 method for class 'ds.id.validation' print(x, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.id.validation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for ds.id.validation Objects — print.ds.id.validation","text":"x ds.id.validation object ... Additional arguments (ignored)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.pca.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for ds.pca Objects — print.ds.pca","title":"Print Method for ds.pca Objects — print.ds.pca","text":"Prints summary PCA results.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.pca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for ds.pca Objects — print.ds.pca","text":"","code":"# S3 method for class 'ds.pca' print(x, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.pca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for ds.pca Objects — print.ds.pca","text":"x ds.pca object ... Additional arguments (ignored)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/summary.ds.glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary Method for ds.glm Objects — summary.ds.glm","title":"Summary Method for ds.glm Objects — summary.ds.glm","text":"Prints detailed summary including deviance fit statistics.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/summary.ds.glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary Method for ds.glm Objects — summary.ds.glm","text":"","code":"# S3 method for class 'ds.glm' summary(object, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/summary.ds.glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary Method for ds.glm Objects — summary.ds.glm","text":"object ds.glm object ... Additional arguments (ignored)","code":""}]
