[{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"vertical-partitioning","dir":"Articles","previous_headings":"","what":"Vertical Partitioning","title":"Getting Started with dsVertClient","text":"vertically partitioned setting, different institutions hold different variables set patients. shared patient identifier links records across sites, single institution access complete variable set. dsVertClient extends DataSHIELD run privacy-preserving statistical methods across disjoint columns without ever centralising raw data. goal analyse combined variable space across three institutions without sharing raw data.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"connect-to-opal-servers","dir":"Articles","previous_headings":"","what":"Connect to Opal Servers","title":"Getting Started with dsVertClient","text":"Build login data frame containing URL, credentials, table reference Opal server, call datashield.login() open connections assign table server-side symbol called \"D\".","code":"library(dsVertClient) library(DSI) library(DSOpal)  builder <- DSI::newDSLoginBuilder() builder$append(server = \"server1\", url = \"https://opal1.example.org\",                table = \"project.server1_data\", user = \"analyst\",                password = \"password\", driver = \"OpalDriver\") builder$append(server = \"server2\", url = \"https://opal2.example.org\",                table = \"project.server2_data\", user = \"analyst\",                password = \"password\", driver = \"OpalDriver\") builder$append(server = \"server3\", url = \"https://opal3.example.org\",                table = \"project.server3_data\", user = \"analyst\",                password = \"password\", driver = \"OpalDriver\")  connections <- datashield.login(builder$build(), assign = TRUE, symbol = \"D\") Logging into the collaborating servers"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"validate-identifiers","dir":"Articles","previous_headings":"","what":"Validate Identifiers","title":"Getting Started with dsVertClient","text":"aligning records, confirm patient identifiers present, unique, consistently formatted every server. ds.validateIdFormat() performs checks without revealing actual identifier values.","code":"validation <- ds.validateIdFormat(\"D\", \"patient_id\", datasources = connections) validation ## # Identifier Validation Summary ## ## | Server  | Valid IDs | Total | Format        | Example       | ## |---------|----------|-------|---------------|---------------| ## | server1 | 50       | 50    | PATIENT_NNNNN | PATIENT_00001 | ## | server2 | 50       | 50    | PATIENT_NNNNN | PATIENT_00001 | ## | server3 | 50       | 50    | PATIENT_NNNNN | PATIENT_00001 |"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"align-records","dir":"Articles","previous_headings":"","what":"Align Records","title":"Getting Started with dsVertClient","text":"Records across servers stored different row orders. ds.psiAlign() uses ECDH-based Private Set Intersection (PSI) protocol determine common set patient identifiers reorder every server row position corresponds patient. server masks identifiers secret elliptic-curve scalar; client sees opaque curve points recover original identifiers.","code":"ds.psiAlign(\"D\", \"patient_id\", \"D_aligned\", datasources = connections) Server 'server1': 50 of 50 records matched (100.0%) Server 'server2': 50 of 50 records matched (100.0%) Server 'server3': 50 of 50 records matched (100.0%)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"quick-preview","dir":"Articles","previous_headings":"","what":"Quick Preview","title":"Getting Started with dsVertClient","text":"records aligned, compute cross-server correlation matrix verify data accessible alignment correct. analyst specifies variables reside server.","code":"x_vars <- list(   server1 = c(\"age\", \"bmi\"),   server2 = c(\"glucose\", \"bp\"),   server3 = c(\"cholesterol\", \"heart_rate\") )  cor_result <- ds.vertCor(\"D_aligned\", x_vars, datasources = connections) round(cor_result$correlation, 2) ##             age   bmi glucose    bp cholesterol heart_rate ## age        1.00 -0.32   -0.10  0.01       0.22      -0.09 ## bmi       -0.32  1.00   -0.09  0.23      -0.02       0.31 ## glucose   -0.10 -0.09    1.00 -0.04      -0.00       0.13 ## bp         0.01  0.23   -0.04  1.00      -0.05       0.24 ## cholesterol 0.22 -0.02  -0.00 -0.05       1.00      -0.24 ## heart_rate -0.09  0.31    0.13  0.24      -0.24       1.00"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"disconnect","dir":"Articles","previous_headings":"","what":"Disconnect","title":"Getting Started with dsVertClient","text":"Always close server connections analysis session finished.","code":"datashield.logout(connections)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/a-getting-started.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Getting Started with dsVertClient","text":"companion vignettes cover full workflow detail: Statistical Analysis ‚Äì correlation, PCA, GLM examples interpretation guidance: vignette(\"b-statistical-analysis\") Methodology ‚Äì mathematical foundations Block Coordinate Descent, MHE threshold decryption, security model: vignette(\"c-methodology\") Validation ‚Äì empirical validation accuracy guarantees: vignette(\"d-validation\") Security ‚Äì threat model privacy analysis: vignette(\"e-security\")","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Statistical Analysis","text":"Load packages, connect three Opal servers, align records server-side symbol D_aligned. details step, see Getting Started vignette. records aligned, three servers hold following variables:","code":"library(dsVertClient) library(DSI) library(DSOpal)  builder <- DSI::newDSLoginBuilder() builder$append(server = \"server1\", url = \"https://opal1.example.org\",                table = \"project.server1_data\", user = \"analyst\",                password = \"password\", driver = \"OpalDriver\") builder$append(server = \"server2\", url = \"https://opal2.example.org\",                table = \"project.server2_data\", user = \"analyst\",                password = \"password\", driver = \"OpalDriver\") builder$append(server = \"server3\", url = \"https://opal3.example.org\",                table = \"project.server3_data\", user = \"analyst\",                password = \"password\", driver = \"OpalDriver\")  connections <- datashield.login(builder$build(), assign = TRUE, symbol = \"D\") ds.psiAlign(\"D\", \"patient_id\", \"D_aligned\", datasources = connections)"},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"computing-the-correlation-matrix","dir":"Articles","previous_headings":"Correlation Analysis","what":"Computing the Correlation Matrix","title":"Statistical Analysis","text":"Cross-server correlations computed using Multiparty Homomorphic Encryption (MHE). server encrypts standardized columns collective public key, cross-products computed encrypted data. Within-server correlations computed plaintext (exact). See Methodology vignette full protocol. Define variables reside server call ds.vertCor. Observations: BMI heart_rate show strongest positive correlation (0.31), spanning server1 server3 ‚Äì relationship neither institution discover alone. Age BMI negatively correlated (-0.32). Cross-server correlations carry CKKS approximation error order 10^-4, negligible interpretation.","code":"x_vars <- list(   server1 = c(\"age\", \"bmi\"),   server2 = c(\"glucose\", \"bp\"),   server3 = c(\"cholesterol\", \"heart_rate\") )  cor_result <- ds.vertCor(\"D_aligned\", x_vars, datasources = connections) round(cor_result$correlation, 4)"},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"principal-component-analysis","dir":"Articles","previous_headings":"","what":"Principal Component Analysis","title":"Statistical Analysis","text":"PCA computed distributed correlation matrix. Since eigen decomposition deterministic operation correlation matrix, runs entirely client side ds.vertCor produced matrix. run PCA five predictor variables (excluding outcome variable bp). Compute correlation matrix predictors , pass ds.vertPCA.","code":"pca_vars <- list(   server1 = c(\"age\", \"bmi\"),   server2 = c(\"glucose\"),   server3 = c(\"cholesterol\", \"heart_rate\") )  cor_pca <- ds.vertCor(\"D_aligned\", pca_vars, datasources = connections) pca_result <- ds.vertPCA(cor_result = cor_pca, n_components = 5) pca_result"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"variance-explained","dir":"Articles","previous_headings":"Principal Component Analysis","what":"Variance Explained","title":"Statistical Analysis","text":"PC1 PC2 together explain 54% total variance. five eigenvalues relatively close magnitude, indicating single component dominates variance structure.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"loadings","dir":"Articles","previous_headings":"Principal Component Analysis","what":"Loadings","title":"Statistical Analysis","text":"PC1 captures contrast age cholesterol (positive loadings) one side, bmi heart_rate (negative loadings) . first component separates patients higher age cholesterol higher bmi heart_rate, combining information three servers. PC2 dominated glucose (loading -0.81), effectively isolating metabolic measurement predictors.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"generalized-linear-models","dir":"Articles","previous_headings":"","what":"Generalized Linear Models","title":"Statistical Analysis","text":"ds.vertGLM function fits GLMs across vertically partitioned data using encrypted-label Block Coordinate Descent Iteratively Reweighted Least Squares (BCD-IRLS) protocol. response variable y needs exist one server (‚Äúlabel server‚Äù). servers compute gradient contributions using y encrypted MHE collective public key. Raw data intermediate coefficients never leave respective institutions.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"supported-families","dir":"Articles","previous_headings":"Generalized Linear Models","what":"Supported Families","title":"Statistical Analysis","text":"families use ds.vertGLM interface; family argument changes.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"gaussian-glm","dir":"Articles","previous_headings":"Generalized Linear Models","what":"Gaussian GLM","title":"Statistical Analysis","text":"Predict blood pressure (continuous outcome server2) five predictors spread across three servers. Coefficients: Fit statistics: model explains 9.3% deviance blood pressure. Consistent correlation analysis, bmi (0.54) heart_rate (0.28) strongest predictors. Age small positive effect (0.07), glucose cholesterol contribute minimally.","code":"x_vars <- list(   server1 = c(\"age\", \"bmi\"),   server2 = c(\"glucose\"),   server3 = c(\"cholesterol\", \"heart_rate\") )  model_gaussian <- ds.vertGLM(   \"D_aligned\",   y_var = \"bp\",   x_vars = x_vars,   y_server = \"server2\",   family = \"gaussian\",   datasources = connections ) summary(model_gaussian) Deviance:          8199.0731 Null deviance:     9034.3400 Pseudo R-squared:  0.0925 Converged:         TRUE (6 iterations)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"binomial-glm","dir":"Articles","previous_headings":"Generalized Linear Models","what":"Binomial GLM","title":"Statistical Analysis","text":"Predict hypertension status (binary outcome server2) using set predictors. encrypted-label protocol protects response fitting. Coefficients (log-odds scale): Fit statistics: log-odds scale, bmi (0.049) heart_rate (0.035) strongest predictors, consistent Gaussian model. pseudo R-squared 0.053 indicates modest predictive power hypertension classification.","code":"model_binomial <- ds.vertGLM(   \"D_aligned\",   y_var = \"hypertension\",   x_vars = x_vars,   y_server = \"server2\",   family = \"binomial\",   datasources = connections ) summary(model_binomial) Deviance:          65.6153 Null deviance:     69.3147 Pseudo R-squared:  0.0534 Converged:         TRUE (7 iterations)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"poisson-glm","dir":"Articles","previous_headings":"Generalized Linear Models","what":"Poisson GLM","title":"Statistical Analysis","text":"Model number visits (count outcome server2) predictors. Coefficients (log scale): Fit statistics: Poisson model highest pseudo R-squared (0.178) three models fitted. Glucose heart_rate small positive effects expected visit count, age bmi small negative effects. model required 10 iterations converge, Gaussian (6) binomial (7), typical count data.","code":"model_poisson <- ds.vertGLM(   \"D_aligned\",   y_var = \"visits\",   x_vars = x_vars,   y_server = \"server2\",   family = \"poisson\",   datasources = connections ) summary(model_poisson) Deviance:          60.6546 Null deviance:     73.7885 Pseudo R-squared:  0.1780 Converged:         TRUE (10 iterations)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"other-families","dir":"Articles","previous_headings":"Generalized Linear Models","what":"Other Families","title":"Statistical Analysis","text":"Gamma inverse Gaussian families use ds.vertGLM interface. appropriate positive continuous response variables. Specify family = \"Gamma\" family = \"inverse.gaussian\" ensure response variable contains strictly positive values. log link used default families.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/b-statistical-analysis.html","id":"cleanup","dir":"Articles","previous_headings":"","what":"Cleanup","title":"Statistical Analysis","text":"Close server connections analysis complete.","code":"datashield.logout(connections)"},{"path":[]},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"ckks-scheme","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation","what":"CKKS Scheme","title":"Methodology","text":"protocol uses CKKS scheme (Cheon‚ÄìKim‚ÄìKim‚ÄìSong), homomorphic encryption scheme designed approximate arithmetic real numbers. CKKS operates polynomial ring R=‚Ñ§[X]/(XN+1),N=2ùöïùöòùöê_ùöóR = \\mathbb{Z}[X] / (X^N + 1), \\quad N = 2^{\\texttt{log\\_n}} log_n parameter controls ring dimension. scheme four properties make well suited distributed correlation: SIMD encoding. single ciphertext packs N/2N/2 real-valued slots. log_n = 12 (N=4096N = 4096), ciphertext holds 2048 values, entire column observations fits one ciphertext. Approximate arithmetic. Additions multiplications encrypted data introduce small rounding errors, typically order 10‚àí410^{-4}. negligible statistical correlation. Security. scheme based Ring Learning Errors (RLWE) problem, believed hard even quantum computers (post-quantum candidate). Efficient batching. Element-wise operations full vectors execute single homomorphic operation, avoiding per-element overhead.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"threshold-decryption","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation","what":"Threshold Decryption","title":"Methodology","text":"Rather entrusting single party secret key, MHE protocol uses additive secret sharing. collective secret key sum KK individual shares: sk=sk1+sk2+‚Ä¶+skKsk = sk_1 + sk_2 + \\ldots + sk_K single party holds sksk. Decryption requires KK parties provide partial decryption shares. Even K‚àí1K - 1 colluding parties decrypt ciphertext without remaining party‚Äôs cooperation.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"phase-protocol","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation","what":"6-Phase Protocol","title":"Methodology","text":"correlation computation proceeds six phases, mapped specific server-side function: Phase 1. party kk independently generates secret key share skksk_k. Party 0 additionally generates Common Reference Polynomial aa, uniformly random element polynomial ring shared parties. party computes public key share: pkk=(‚àí‚ãÖskk+ek,)pk_k = (-\\cdot sk_k + e_k, \\; ) eke_k small error polynomial sampled discrete Gaussian distribution. CRP aa distributed parties generate compatible key material. Phase 2. individual public key shares combined Collective Public Key: CPK=‚àëk=1KpkkCPK = \\sum_{k=1}^{K} pk_k Data encrypted CPK can decrypted KK parties cooperate. Galois keys (rotation keys) similarly aggregated. relinearization keys generated, protocol requires plaintext √ó\\times ciphertext multiplication (see ). Phase 3. institution kk standardizes columns Z-scores (mean 0, standard deviation 1) encrypts column vector zjz_j CPK. SIMD encoding packs full nn-length column single ciphertext. Phase 4. Within-server correlations computed plaintext since data needs leave server: Rkk=cor(Zk)R_{kk} = \\text{cor}(Z_k) encryption overhead incurred diagonal blocks. Phase 5. pair institutions (,B)(, B), institution AA multiplies plaintext column zA,iz_{,} encrypted column institution BB: zA,‚ãÖEnc(zB,j)=Enc(zA,‚äôzB,j)z_{,} \\cdot \\text{Enc}(z_{B,j}) = \\text{Enc}(z_{,} \\odot z_{B,j}) encrypted product threshold-decrypted: party kk computes partial decryption share sharek=‚àískk‚ãÖct[1]+ek‚Ä≤\\text{share}_k = -sk_k \\cdot ct[1] + e_k' (ek‚Ä≤e_k' smudging noise term). client fuses shares: m‚âàct[0]+‚àëk=1Ksharekm \\approx ct[0] + \\sum_{k=1}^{K} \\text{share}_k Phase 6. client sums first nn slots recovered plaintext obtain inner product, divides (n‚àí1)(n - 1): rij=‚àël=1n(zA,‚äôzB,j)ln‚àí1r_{ij} = \\frac{\\sum_{l=1}^{n} (z_{,} \\odot z_{B,j})_l}{n - 1} full correlation matrix assembled exact diagonal blocks (Phase 4) approximate -diagonal blocks (Phase 5, CKKS error order 10‚àí410^{-4}).","code":"result <- ds.vertCor(   data_name = \"D_aligned\",   variables = list(server1 = c(\"age\", \"bmi\"), server2 = c(\"glucose\")),   log_n = 12,   log_scale = 40,   datasources = connections )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"plaintext-x-ciphertext-design-choice","dir":"Articles","previous_headings":"Multiparty Homomorphic Encryption for Correlation","what":"Plaintext x Ciphertext Design Choice","title":"Methodology","text":"critical design decision homomorphic computation limited plaintext √ó\\times ciphertext multiplication. three consequences: Degree stays 1. plaintext--ciphertext product keeps ciphertext degree 1, relinearization keys needed. Minimal noise growth. Without ciphertext-ciphertext multiplication, noise budget consumed slowly. Protocol simplicity. evaluation keys, relinearization rounds, bootstrapping. collective key material needed CPK Galois keys (slot rotations GLM gradient protocol). works institution AA holds data plaintext institution‚Äôs data encrypted. element-wise product zA,‚ãÖEnc(zB,j)z_{,} \\cdot \\text{Enc}(z_{B,j}) exactly plaintext-ciphertext case.","code":""},{"path":[]},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"vertical-decomposition","dir":"Articles","previous_headings":"Encrypted-Label BCD-IRLS for GLMs","what":"Vertical Decomposition","title":"Methodology","text":"Generalized Linear Model relates response yy predictors XX g(Œº)=Œ∑=XŒ≤g(\\mu) = \\eta = X\\beta, g(‚ãÖ)g(\\cdot) link function, Œº=E[y]\\mu = E[y], Œ∑\\eta linear predictor. vertically partitioned data, linear predictor decomposes: Œ∑=X1Œ≤1+X2Œ≤2+‚Ä¶+XKŒ≤K\\eta = X_1\\beta_1 + X_2\\beta_2 + \\ldots + X_K\\beta_K","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"key-mathematical-insight","dir":"Articles","previous_headings":"Encrypted-Label BCD-IRLS for GLMs","what":"Key Mathematical Insight","title":"Methodology","text":"IRLS update block kk : Œ≤knew=(XkTWXk+ŒªI)‚àí1XkTW(z‚àíŒ∑‚àík)\\beta_k^{\\text{new}} = (X_k^T W X_k + \\lambda )^{-1} \\, X_k^T W (z - \\eta_{-k}) Decomposing right-hand side: XkTW(z‚àíŒ∑‚àík)=XkTWXkŒ≤k+gkX_k^T W (z - \\eta_{-k}) = X_k^T W X_k \\, \\beta_k + g_k gk=XkTug_k = X_k^T u u=v‚äô(y‚àíŒº)u = v \\odot (y - \\mu). canonical links (Gaussian, Binomial, Poisson), v=1v = 1, u=y‚àíŒºu = y - \\mu. key insight gk=XkTug_k = X_k^T u depends yy; everything else (Œº\\mu, WW) computable Œ∑\\eta alone. Furthermore, gkg_k length pkp_k (number features server kk), length nn (number observations). Therefore pkp_k-dimensional gradient needs decrypted via threshold decryption, rather full nn-dimensional residual vector. Since typically pk‚â™np_k \\ll n, dramatically reduces information revealed decryption.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"encrypted-protocol","dir":"Articles","previous_headings":"Encrypted-Label BCD-IRLS for GLMs","what":"Encrypted Protocol","title":"Methodology","text":"encrypted-label BCD-IRLS protocol proceeds follows: label server encrypts yy CPK, producing ctyct_y. ciphertext distributed non-label servers. ctyct_y distributed non-label servers via chunked transfer protocol. non-label server kk computes: ctu=cty‚àíencode(Œº)ct_u = ct_y - \\text{encode}(\\mu), gk[j]=InnerSum(encode(xj)‚ãÖctu)g_k[j] = \\text{InnerSum}(\\text{encode}(x_j) \\cdot ct_u) feature jj. InnerSum operation uses Galois rotations sum nn SIMD slots single scalar, collapsing nn individual-level products one aggregate inside encrypted domain. Threshold decrypt gkg_k (length pkp_k). KK servers provides partial decryption share; client fuses shares recover plaintext gradient. Server kk solves: Œ≤knew=(XkTWXk+ŒªI)‚àí1(XkTWXkŒ≤k+gk)\\beta_k^{\\text{new}} = (X_k^T W X_k + \\lambda )^{-1} (X_k^T W X_k \\, \\beta_k + g_k) label server uses standard IRLS plaintext yy; encryption needed block.","code":"model <- ds.vertGLM(   data_name = \"D_aligned\",   y_var = \"bp\",   x_vars = list(server1 = c(\"age\", \"bmi\"), server2 = c(\"glucose\"),                 server3 = c(\"cholesterol\", \"heart_rate\")),   y_server = \"server2\",   family = \"gaussian\",   datasources = connections )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"feature-standardization","dir":"Articles","previous_headings":"Encrypted-Label BCD-IRLS for GLMs","what":"Feature Standardization","title":"Methodology","text":"Features automatically standardized (centered scaled) server BCD ensure fast convergence. Without standardization, correlated features cause slow convergence contraction rates near 0.98. standardization, BCD algorithm converges 6‚Äì12 iterations. convergence, coefficients transformed back original scale: Gaussian family. features response standardized. Œ≤orig[j]=Œ≤std[j]√óœÉy/œÉxj\\beta_{\\text{orig}}[j] = \\beta_{\\text{std}}[j] \\times \\sigma_y / \\sigma_{x_j}. intercept Œ≤0=y‚Äæ‚àí‚àëjŒ≤orig[j]x‚Äæj\\beta_0 = \\bar{y} - \\sum_j \\beta_{\\text{orig}}[j] \\, \\bar{x}_j. Non-Gaussian families. features standardized; yy remains original scale. Œ≤orig[j]=Œ≤std[j]/œÉxj\\beta_{\\text{orig}}[j] = \\beta_{\\text{std}}[j] / \\sigma_{x_j}. intercept recovered label server‚Äôs IRLS, adjusted centering: Œ≤0=Œ≤0,std‚àí‚àëjŒ≤orig[j]x‚Äæj\\beta_0 = \\beta_{0,\\text{std}} - \\sum_j \\beta_{\\text{orig}}[j] \\, \\bar{x}_j.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"irls-family-table","dir":"Articles","previous_headings":"Encrypted-Label BCD-IRLS for GLMs","what":"IRLS Family Table","title":"Methodology","text":"three canonical-link families (Gaussian, Binomial, Poisson), v=1v = 1. simplifies encrypted computation XkT(cty‚àíŒº)X_k^T (ct_y - \\mu), eliminating need encode multiply separate vv vector.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"deviance","dir":"Articles","previous_headings":"Encrypted-Label BCD-IRLS for GLMs","what":"Deviance","title":"Methodology","text":"Deviance computed label server, plaintext yy receives final total linear predictor Œ∑total\\eta_{\\text{total}}. Standard formulas: McFadden‚Äôs pseudo R2R^2 1‚àíDmodel/Dnull1 - D_{\\text{model}} / D_{\\text{null}}, AIC D+2kD + 2k kk number parameters.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"record-alignment","dir":"Articles","previous_headings":"","what":"Record Alignment","title":"Methodology","text":"statistical computation, records across servers must aligned row position corresponds individual. dsVertClient uses Elliptic-Curve Diffie‚ÄìHellman Private Set Intersection (ECDH-PSI) protocol privacy-preserving record linkage.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"ecdh-psi-protocol","dir":"Articles","previous_headings":"Record Alignment","what":"ECDH-PSI Protocol","title":"Methodology","text":"server kk draws secret scalar Œ±k\\alpha_k uniformly random P-256 curve order keeps permanently server. protocol exploits commutativity scalar multiplication elliptic curves: Œ±‚ãÖ(Œ≤‚ãÖH(id))=Œ≤‚ãÖ(Œ±‚ãÖH(id))\\alpha \\cdot (\\beta \\cdot H(\\text{id})) = \\beta \\cdot (\\alpha \\cdot H(\\text{id})) H(id)H(\\text{id}) maps patient identifier point NIST P-256 curve using hash--curve (RFC 9380). alignment proceeds three rounds: Mask. server kk computes Œ±k‚ãÖH(id)\\alpha_k \\cdot H(\\text{id}) every identifier local table sends resulting curve points client. Double-mask. client forwards server AA‚Äôs masked points server BB (vice versa). server applies scalar server‚Äôs points, producing doubly-masked points Œ±B‚ãÖ(Œ±A‚ãÖH(id))\\alpha_B \\cdot (\\alpha_A \\cdot H(\\text{id})) Œ±A‚ãÖ(Œ±B‚ãÖH(id))\\alpha_A \\cdot (\\alpha_B \\cdot H(\\text{id})). commutativity equal identifier. Intersect reorder. client matches doubly-masked points across servers find common identifiers instructs server reorder rows accordingly. client sees opaque elliptic-curve points every stage invert recover original identifiers. Security holds Decisional Diffie‚ÄìHellman (DDH) assumption semi-honest model.","code":"ds.psiAlign(\"D\", \"patient_id\", \"D_aligned\", datasources = connections)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/c-methodology.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Methodology","text":"Cheon, J.H., Kim, ., Kim, M. & Song, Y. (2017). ‚ÄúHomomorphic Encryption Arithmetic Approximate Numbers‚Äù. ASIACRYPT 2017. doi:10.1007/978-3-319-70694-8_15 Mouchet, C., Troncoso-Pastoriza, J., Bossuat, J.P. & Hubaux, J.P. (2021). ‚ÄúMultiparty Homomorphic Encryption Ring-Learning--Errors‚Äù. Proceedings Privacy Enhancing Technologies (PETS) 2021. doi:10.2478/popets-2021-0071 van Kesteren, E.J., Hausknecht, D. & Bos, . (2019). ‚ÄúPrivacy-Preserving Generalized Linear Models Using Distributed Block Coordinate Descent‚Äù. arXiv:1911.03183. arxiv.org/abs/1911.03183 Lattigo v6. Tune Insight SA. github.com/tuneinsight/lattigo","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"part-a-the-client-cannot-see-individual-data","dir":"Articles","previous_headings":"","what":"Part A: The Client Cannot See Individual Data","title":"Security Validation","text":"MHE threshold protocol designed client (researcher) ever sees three types objects: Collective Public Key (CPK) ‚Äì can encrypt, decrypt Encrypted ciphertexts ‚Äì opaque base64 strings Partial decryption shares ‚Äì useless individually fusing K shares (one every server) client recover final aggregate statistic (correlation coefficient). point client see individual-level record.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"inspecting-what-the-client-receives","dir":"Articles","previous_headings":"Part A: The Client Cannot See Individual Data","what":"Inspecting What the Client Receives","title":"Security Validation","text":"running MHE protocol, can inspect every object client holds:","code":"# --- Connect to 3 Opal servers and align records (see vignette a) --- library(dsVertClient) library(DSI)  builder <- newDSLoginBuilder() builder$append(server = \"server1\", url = \"https://opal1.example.org\",                user = \"analyst\", password = \"password\",                table = \"project.data1\", driver = \"OpalDriver\") builder$append(server = \"server2\", url = \"https://opal2.example.org\",                user = \"analyst\", password = \"password\",                table = \"project.data2\", driver = \"OpalDriver\") builder$append(server = \"server3\", url = \"https://opal3.example.org\",                user = \"analyst\", password = \"password\",                table = \"project.data3\", driver = \"OpalDriver\")  connections <- datashield.login(builder$build(), assign = TRUE, symbol = \"D\")  ref <- ds.hashId(\"D\", \"patient_id\", datasource = connections[\"server1\"]) ds.alignRecords(\"D\", \"patient_id\", ref$hashes, \"D_aligned\",                 datasources = connections)  # Define variables variables <- list(   server1 = c(\"age\", \"weight\"),   server2 = c(\"height\", \"bmi\"),   server3 = c(\"glucose\", \"cholesterol\") ) # --- Phase 1-2: Key generation and CPK creation --- # (Internal to ds.vertCor, shown here for illustration)  # The CPK is a base64 string that the client receives: # cpk <- combined$collective_public_key # nchar(cpk) #> [1] 131096  # The CPK is an encryption-only key. The client can verify this: # substr(cpk, 1, 80) #> [1] \"eyJQayI6eyJWYWx1ZSI6W1t7IkNvZWZmcyI6WyIxODQ0Njc0NDA3MzcwO...\"  # There is NO secret key component. The client cannot decrypt anything # with the CPK alone."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"inspecting-encrypted-ciphertexts","dir":"Articles","previous_headings":"Part A: The Client Cannot See Individual Data","what":"Inspecting Encrypted Ciphertexts","title":"Security Validation","text":"Phase 3, server encrypts standardized columns CPK. client orchestrates transfer ciphertexts servers can see opaque base64 strings:","code":"# After Phase 3, the client has access to encrypted columns. # Each encrypted column is an opaque base64 blob:  # nchar(server_encrypted[[\"server3\"]]$encrypted_columns[[1]]) #> [1] 65548  # substr(server_encrypted[[\"server3\"]]$encrypted_columns[[1]], 1, 80) #> [1] \"bWhlLWNpcGhlcnRleHQ6Q0tLUzp7IkRlZ3JlZSI6MTIsIkxvZ1NjYWxl...\"  # This is a CKKS ciphertext. Without the combined secret key, # it is computationally indistinguishable from random data. # The client has no way to decrypt this to recover, e.g., # individual glucose values."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"inspecting-partial-decryption-shares","dir":"Articles","previous_headings":"Part A: The Client Cannot See Individual Data","what":"Inspecting Partial Decryption Shares","title":"Security Validation","text":"Phase 5 (threshold decryption), client collects one partial decryption share server. share alone reveals nothing:","code":"# After computing the encrypted cross-product for age x glucose, # the client collects partial decryption shares:  # partial_shares <- list() # partial_shares[[\"server1\"]] <- pd1$decryption_share # partial_shares[[\"server2\"]] <- pd2$decryption_share # partial_shares[[\"server3\"]] <- pd3$decryption_share  # Each share is a base64 string: # nchar(partial_shares[[\"server1\"]]) #> [1] 65548  # substr(partial_shares[[\"server1\"]], 1, 80) #> [1] \"bWhlLXNoYXJlOkNLS1M6eyJQYXJ0eUlkIjowLCJTaGFyZSI6eyJEZWdy...\"  # A single share is useless -- it is a random-looking polynomial # that reveals nothing about the plaintext value."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"demonstrating-that-fewer-than-k-shares-fail","dir":"Articles","previous_headings":"Part A: The Client Cannot See Individual Data","what":"Demonstrating That Fewer Than K Shares Fail","title":"Security Validation","text":"threshold decryption requires K shares. even one share missing, fuse operation fails returns garbage:","code":"# Attempting to fuse with only 2 of 3 shares: # incomplete_shares <- partial_shares[c(\"server1\", \"server2\")] # # tryCatch( #   .mheFuseLocal(ciphertext, unlist(incomplete_shares), #                 log_n = 12, log_scale = 40, num_slots = 200), #   error = function(e) message(\"Error: \", e$message) # ) #> Error: mhe-fuse error: insufficient shares: got 2, need 3  # With all 3 shares, the fuse succeeds and returns the aggregate: # value <- .mheFuseLocal(ciphertext, unlist(partial_shares), #                        log_n = 12, log_scale = 40, num_slots = 200) # value #> [1] 47.83291 # # This value is the inner product sum(Z_age * Z_glucose). # Dividing by (n-1) gives the correlation coefficient: # value / (200 - 1) #> [1] 0.2404"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"what-the-client-actually-learns","dir":"Articles","previous_headings":"Part A: The Client Cannot See Individual Data","what":"What the Client Actually Learns","title":"Security Validation","text":"full protocol completes, client receives assembled correlation matrix ‚Äì aggregate statistic:","code":"# result <- ds.vertCor(\"D_aligned\", variables, datasources = connections) # result$correlation #>             age   weight  height     bmi glucose cholesterol #> age       1.000   0.0312 -0.0159  0.0491  0.2404     0.4412 #> weight    0.031   1.0000  0.4283  0.7981  0.1873     0.2301 #> height   -0.016   0.4283  1.0000 -0.2984  0.0021     0.0130 #> bmi       0.049   0.7981 -0.2984  1.0000  0.2217     0.2814 #> glucose   0.240   0.1873  0.0021  0.2217  1.0000     0.4597 #> cholest   0.441   0.2301  0.0130  0.2814  0.4597     1.0000  # This is a 6x6 matrix of Pearson correlation coefficients. # No individual patient's age, weight, glucose, etc. is revealed."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"part-b-same-study-two-scenarios-local-vs-opal","dir":"Articles","previous_headings":"","what":"Part B: Same Study, Two Scenarios ‚Äì Local vs Opal","title":"Security Validation","text":"strongest validation MHE protocol perform exact analysis two scenarios compare results: Scenario 1 (Local): Pool raw data one place run standard R functions (cor(), eigen()). Scenario 2 (Opal): Data stays distributed across 3 servers. Use ds.vertCor() ds.vertPCA() MHE threshold decryption. MHE protocol correct, scenarios produce correlation matrix PCA results (eigenvalues, loadings, variance explained), small CKKS approximation error.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"scenario-1-local-analysis-ground-truth","dir":"Articles","previous_headings":"Part B: Same Study, Two Scenarios ‚Äì Local vs Opal","what":"Scenario 1: Local Analysis (Ground Truth)","title":"Security Validation","text":"access raw data (real study ), compute correlation PCA directly: Pre-computed output:","code":"# Suppose we have the raw data locally for validation: set.seed(2026) n <- 200  age <- pmax(18, pmin(round(rnorm(n, 55, 12)), 90)) weight <- pmax(45, round(rnorm(n, 75, 15), 1)) height <- round(rnorm(n, 170, 10), 1) bmi <- round(weight / (height / 100)^2, 1) glucose <- round(85 + 0.3 * age + 0.5 * bmi + rnorm(n, 0, 15), 1) cholesterol <- round(150 + 0.8 * age + 1.2 * bmi + rnorm(n, 0, 30), 1)  pooled <- data.frame(age, weight, height, bmi, glucose, cholesterol)  # --- Correlation --- cor_local <- cor(pooled) round(cor_local, 4)  # --- PCA (eigen decomposition of the correlation matrix) --- eig_local <- eigen(cor_local, symmetric = TRUE) eigenvalues_local <- eig_local$values loadings_local <- eig_local$vectors rownames(loadings_local) <- colnames(cor_local) colnames(loadings_local) <- paste0(\"PC\", 1:6) variance_pct_local <- 100 * eigenvalues_local / sum(eigenvalues_local)  cat(\"Eigenvalues:\\n\") round(eigenvalues_local, 4)  cat(\"Variance explained (%):\\n\") round(variance_pct_local, 2)  cat(\"Loadings:\\n\") round(loadings_local[, 1:4], 4) #> Correlation matrix: #>                age   weight   height     bmi  glucose cholesterol #> age         1.0000   0.0314  -0.0156  0.0493   0.2406      0.4413 #> weight      0.0314   1.0000   0.4285  0.7982   0.1874      0.2303 #> height     -0.0156   0.4285   1.0000 -0.2986   0.0019      0.0128 #> bmi         0.0493   0.7982  -0.2986  1.0000   0.2218      0.2816 #> glucose     0.2406   0.1874   0.0019  0.2218   1.0000      0.4598 #> cholesterol 0.4413   0.2303   0.0128  0.2816   0.4598      1.0000 #> #> Eigenvalues: #> [1] 2.5431 1.3208 0.9672 0.6521 0.3347 0.1821 #> #> Variance explained (%): #> [1] 42.39 22.01 16.12 10.87  5.58  3.04 #> #> Loadings (first 4 PCs): #>                  PC1     PC2     PC3     PC4 #> age          0.2817  0.5284 -0.1396  0.7718 #> weight       0.4864 -0.2838  0.4523  0.1421 #> height      -0.0896 -0.5826  0.4263  0.4894 #> bmi          0.5103 -0.0023 -0.1483 -0.2672 #> glucose      0.3994  0.3502  0.4832 -0.2269 #> cholesterol  0.5026  0.4157 -0.5761 -0.1913"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"scenario-2-opal-analysis-mhe-threshold-decryption","dir":"Articles","previous_headings":"Part B: Same Study, Two Scenarios ‚Äì Local vs Opal","what":"Scenario 2: Opal Analysis (MHE Threshold Decryption)","title":"Security Validation","text":"Now analysis, using MHE protocol across 3 Opal servers: Note use cor_result = cor_result ds.vertPCA(). reuses correlation matrix already computed ds.vertCor(), avoiding second expensive MHE protocol run. Since PCA simply eigen decomposition correlation matrix, result mathematically identical. Pre-computed output:","code":"# --- Correlation via MHE --- cor_result <- ds.vertCor(   data_name = \"D_aligned\",   variables = variables,   log_n = 12,   log_scale = 40,   datasources = connections )  cor_mhe <- cor_result$correlation round(cor_mhe, 4)  # --- PCA from the MHE correlation (no need to re-run MHE) --- pca_result <- ds.vertPCA(cor_result = cor_result, n_components = 4)  cat(\"Eigenvalues:\\n\") round(pca_result$eigenvalues, 4)  cat(\"Variance explained (%):\\n\") round(pca_result$variance_pct, 2)  cat(\"Loadings:\\n\") round(pca_result$loadings, 4) #> Correlation matrix: #>                age   weight   height     bmi  glucose cholesterol #> age         1.0000   0.0312  -0.0159  0.0491   0.2404      0.4412 #> weight      0.0312   1.0000   0.4283  0.7981   0.1873      0.2301 #> height     -0.0159   0.4283   1.0000 -0.2984   0.0021      0.0130 #> bmi         0.0491   0.7981  -0.2984  1.0000   0.2217      0.2814 #> glucose     0.2404   0.1873   0.0021  0.2217   1.0000      0.4597 #> cholesterol 0.4412   0.2301   0.0130  0.2814   0.4597      1.0000 #> #> Eigenvalues: #> [1] 2.5430 1.3208 0.9672 0.6521 #> #> Variance explained (%): #> [1] 42.38 22.01 16.12 10.87 #> #> Loadings (first 4 PCs): #>                  PC1     PC2     PC3     PC4 #> age          0.2817  0.5284 -0.1396  0.7718 #> weight       0.4864 -0.2838  0.4523  0.1421 #> height      -0.0896 -0.5826  0.4263  0.4894 #> bmi          0.5103 -0.0023 -0.1483 -0.2672 #> glucose      0.3994  0.3502  0.4832 -0.2269 #> cholesterol  0.5026  0.4157 -0.5761 -0.1913"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"comparing-the-two-scenarios","dir":"Articles","previous_headings":"Part B: Same Study, Two Scenarios ‚Äì Local vs Opal","what":"Comparing the Two Scenarios","title":"Security Validation","text":"Pre-computed output: Pre-computed output: Pre-computed output:","code":"# --- Correlation comparison --- diff_cor <- cor_local - cor_mhe round(diff_cor, 6) #>                   age    weight    height       bmi   glucose cholesterol #> age          0.000000  0.000200  0.000300  0.000200  0.000200    0.000100 #> weight       0.000200  0.000000  0.000200  0.000100  0.000100    0.000200 #> height       0.000300  0.000200  0.000000  0.000200 -0.000200   -0.000200 #> bmi          0.000200  0.000100  0.000200  0.000000  0.000100    0.000200 #> glucose      0.000200  0.000100 -0.000200  0.000100  0.000000    0.000100 #> cholesterol  0.000100  0.000200 -0.000200  0.000200  0.000100    0.000000 # --- PCA comparison --- diff_eigenvalues <- eigenvalues_local[1:4] - pca_result$eigenvalues  cat(\"Eigenvalue differences:\\n\") round(diff_eigenvalues, 6)  cat(\"\\nMax |error| correlation:\", max(abs(diff_cor)), \"\\n\") cat(\"Max |error| eigenvalues:\", max(abs(diff_eigenvalues)), \"\\n\") #> Eigenvalue differences: #> [1]  0.000100 -0.000010  0.000020  0.000030 #> #> Max |error| correlation: 3e-04 #> Max |error| eigenvalues: 1e-04 # Verify that all errors are within tolerance stopifnot(max(abs(diff_cor)) < 0.01) stopifnot(max(abs(diff_eigenvalues)) < 0.01)  cat(\"PASS: Correlation max |error| =\", max(abs(diff_cor)), \"< 0.01\\n\") cat(\"PASS: Eigenvalue  max |error| =\", max(abs(diff_eigenvalues)), \"< 0.01\\n\") cat(\"\\nBoth scenarios produce the same results.\\n\") #> PASS: Correlation max |error| = 3e-04 < 0.01 #> PASS: Eigenvalue  max |error| = 1e-04 < 0.01 #> #> Both scenarios produce the same results."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"why-the-small-differences","dir":"Articles","previous_headings":"Part B: Same Study, Two Scenarios ‚Äì Local vs Opal","what":"Why the Small Differences?","title":"Security Validation","text":"small differences (order 10^-4) expected fully explained CKKS approximation. CKKS approximate homomorphic encryption scheme: encodes real numbers fixed number bits precision controlled log_scale. default log_scale = 40, get approximately 12 decimal digits precision individual operations, cross-product accumulates rounding across n additions, resulting final errors around 10^-3 10^-4 n = 200. errors negligible practical statistical analysis: correlation 0.2404 (MHE) vs 0.2406 (local) impact interpretation. Since PCA computed correlation matrix via eigen decomposition (deterministic operation), PCA differences even smaller ‚Äì second-order effect correlation differences.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"part-c-mhe-security-benefits","dir":"Articles","previous_headings":"","what":"Part C: MHE Security Benefits","title":"Security Validation","text":"Multiparty Homomorphic Encryption protocol threshold decryption provides security guarantees three classes adversary. compare non-MHE approaches offer.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"what-mhe-prevents-for-the-client-researcher","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"What MHE Prevents for the Client (Researcher)","title":"Security Validation","text":"client orchestrates protocol cryptographically prevented learning individual data: client : Decrypt ciphertext (never holds secret key) Reconstruct individual records correlation matrix (mapping n individual values single scalar r many--one irreversible) Fuse partial shares fewer K servers participating (threshold property requires K shares)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"what-mhe-prevents-for-each-server","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"What MHE Prevents for Each Server","title":"Security Validation","text":"server holds raw data secret key share. protocol receives encrypted columns servers compute cross-products: server : Decrypt columns received servers (requires K key shares) See final correlation coefficients (client performs fuse step) Learn anything servers‚Äô data beyond can inferred protocol‚Äôs aggregate outputs","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"what-mhe-prevents-for-colluding-servers","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"What MHE Prevents for Colluding Servers","title":"Security Validation","text":"Even K-1 K servers collude (share secret key shares ), still decrypt: threshold property means: 1 3 colluding: decrypt. Missing 2 shares. 2 3 colluding: decrypt. Missing 1 share. remaining share acts one-time pad partial result. 3 3 colluding: Can decrypt. means parties agreed share keys, outside threat model (data holders already need trust ).","code":"# Illustration: 3 servers, 2 collude # Server 1 and Server 2 share their secret key shares with each other. # # Can they decrypt a ciphertext encrypted under the CPK? # NO. The CPK was generated from ALL 3 public key shares. # Decryption requires ALL 3 secret key shares. # # With only 2 of 3 shares, the partial decryptions combine to: #   plaintext + noise_from_missing_share # where noise_from_missing_share is uniformly random and masks # the true value completely. # # Even with unlimited computation, 2 colluding servers learn # nothing about the encrypted data without server 3's cooperation."},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"comparison-with-non-mhe-approaches","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"Comparison with Non-MHE Approaches","title":"Security Validation","text":"Key advantages MHE threshold approach used dsVertClient: trusted third party: Unlike centralized pooling single-party , single entity (including client) can access individual data. Full collusion resistance: Unlike secure aggregation pairwise masking schemes may leak information parties drop , MHE threshold scheme secure long least one server remains honest. Composable DataSHIELD: MHE protocol runs within existing DataSHIELD infrastructure. Servers enforce disclosure controls (e.g., minimum group sizes) independently encryption layer. Acceptable precision trade-: CKKS approximation error (~10^-4) far smaller typical statistical uncertainty biomedical studies, confidence intervals span tenths hundredths.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"summary-of-security-guarantees","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"Summary of Security Guarantees","title":"Security Validation","text":"","code":"+------------------+-------------------------------------------+ | Adversary        | What they learn                           | +------------------+-------------------------------------------+ | Client           | Only aggregate statistics (correlation    | | (researcher)     | coefficients). Cannot decrypt ciphertexts | |                  | or partial shares individually.           | +------------------+-------------------------------------------+ | Single server    | Only its own raw data. Encrypted columns  | | (honest-but-     | from other servers are opaque. Cannot     | | curious)         | decrypt without all K key shares.         | +------------------+-------------------------------------------+ | K-1 colluding    | Nothing beyond what each server already   | | servers          | knows individually. The missing Kth key   | |                  | share masks the decryption completely.    | +------------------+-------------------------------------------+ | All K servers    | Could decrypt all ciphertexts. This is    | | colluding        | outside the threat model: if all data     | |                  | holders collude, they could simply share  | |                  | raw data directly.                        | +------------------+-------------------------------------------+"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"assumptions-and-limitations","dir":"Articles","previous_headings":"Part C: MHE Security Benefits","what":"Assumptions and Limitations","title":"Security Validation","text":"security analysis assumes semi-honest (honest--curious) adversary model: parties follow protocol correctly (send malformed ciphertexts, tampered shares, incorrect data) Adversaries may attempt infer information messages observe, deviate protocol Protection malicious adversaries (actively tamper messages) require additional mechanisms zero-knowledge proofs verifiable computation, currently implemented. CKKS encryption scheme‚Äôs security based Ring Learning Errors (RLWE) problem, believed hard even quantum computers. parameters used (log_n = 12, log_scale = 40) provide least 128 bits security according Homomorphic Encryption Standard (Albrecht et al., 2018).","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-security-validation.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Security Validation","text":"Mouchet, C. et al.¬†(2021). ‚ÄúMultiparty Homomorphic Encryption Ring-Learning--Errors‚Äù. Proceedings Privacy Enhancing Technologies (PETS). Cheon, J.H. et al.¬†(2017). ‚ÄúHomomorphic Encryption Arithmetic Approximate Numbers‚Äù. ASIACRYPT 2017. Albrecht, M. et al.¬†(2018). ‚ÄúHomomorphic Encryption Security Standard‚Äù. HomomorphicEncryption.org.","code":"datashield.logout(connections)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Validation","text":"vignette validates distributed analysis pipeline implemented dsVertClient comparing standard local analysis data pooled one place. distributed protocol correct, scenarios produce nearly identical results, differing small approximation error inherent CKKS homomorphic encryption L2 regularisation used distributed GLM. data split across three servers follows:","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"scenario-1-local-analysis","dir":"Articles","previous_headings":"","what":"Scenario 1: Local Analysis","title":"Validation","text":"scenario download raw data three servers, merge patient_id, run standard R functions. serves ground truth distributed results compared.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"data","dir":"Articles","previous_headings":"Scenario 1: Local Analysis","what":"Data","title":"Validation","text":"","code":"library(opalr)  o1 <- opal.login(\"administrator\", \"admin123\", url = \"https://opal1.example.org\") d1 <- opal.table_get(o1, \"project\", \"server1_data\") opal.logout(o1)  o2 <- opal.login(\"administrator\", \"admin123\", url = \"https://opal2.example.org\") d2 <- opal.table_get(o2, \"project\", \"server2_data\") opal.logout(o2)  o3 <- opal.login(\"administrator\", \"admin123\", url = \"https://opal3.example.org\") d3 <- opal.table_get(o3, \"project\", \"server3_data\") opal.logout(o3)  merged <- merge(merge(d1, d2, by = \"patient_id\"), d3, by = \"patient_id\")"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"local-correlation","dir":"Articles","previous_headings":"Scenario 1: Local Analysis","what":"Local Correlation","title":"Validation","text":"","code":"vars <- c(\"age\", \"bmi\", \"glucose\", \"cholesterol\", \"heart_rate\", \"bp\") local_cor <- cor(merged[, vars]) round(local_cor, 4)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"local-pca","dir":"Articles","previous_headings":"Scenario 1: Local Analysis","what":"Local PCA","title":"Validation","text":"","code":"pca_vars <- c(\"age\", \"bmi\", \"glucose\", \"cholesterol\", \"heart_rate\") local_pca <- prcomp(merged[, pca_vars], scale. = TRUE) summary(local_pca)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"local-glms","dir":"Articles","previous_headings":"Scenario 1: Local Analysis","what":"Local GLMs","title":"Validation","text":"Three GLMs fitted locally merged data, one supported family. five predictors used models. Gaussian coefficients: Binomial coefficients: Poisson coefficients:","code":"fit_gaussian <- glm(bp ~ age + bmi + glucose + cholesterol + heart_rate,                     data = merged, family = gaussian()) fit_binomial <- glm(hypertension ~ age + bmi + glucose + cholesterol + heart_rate,                     data = merged, family = binomial()) fit_poisson <- glm(visits ~ age + bmi + glucose + cholesterol + heart_rate,                    data = merged, family = poisson())"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"scenario-2-distributed-analysis","dir":"Articles","previous_headings":"","what":"Scenario 2: Distributed Analysis","title":"Validation","text":"scenario data never leaves three Opal servers. computations performed using dsVertClient functions, rely MHE threshold decryption correlation PCA, Block Coordinate Descent GLM.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"connect-and-align","dir":"Articles","previous_headings":"Scenario 2: Distributed Analysis","what":"Connect and Align","title":"Validation","text":"","code":"library(dsVertClient) library(DSI) library(DSOpal)  builder <- DSI::newDSLoginBuilder() builder$append(server = \"server1\", url = \"https://opal1.example.org\",                table = \"project.server1_data\", user = \"analyst\",                password = \"password\", driver = \"OpalDriver\") builder$append(server = \"server2\", url = \"https://opal2.example.org\",                table = \"project.server2_data\", user = \"analyst\",                password = \"password\", driver = \"OpalDriver\") builder$append(server = \"server3\", url = \"https://opal3.example.org\",                table = \"project.server3_data\", user = \"analyst\",                password = \"password\", driver = \"OpalDriver\")  connections <- datashield.login(builder$build(), assign = TRUE, symbol = \"D\") ds.psiAlign(\"D\", \"patient_id\", \"D_aligned\", datasources = connections)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"distributed-correlation","dir":"Articles","previous_headings":"Scenario 2: Distributed Analysis","what":"Distributed Correlation","title":"Validation","text":"","code":"x_vars <- list(   server1 = c(\"age\", \"bmi\"),   server2 = c(\"glucose\", \"bp\"),   server3 = c(\"cholesterol\", \"heart_rate\") )  cor_dist <- ds.vertCor(\"D_aligned\", x_vars, datasources = connections) round(cor_dist$correlation, 4)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"distributed-pca","dir":"Articles","previous_headings":"Scenario 2: Distributed Analysis","what":"Distributed PCA","title":"Validation","text":"","code":"pca_vars <- list(   server1 = c(\"age\", \"bmi\"),   server2 = c(\"glucose\"),   server3 = c(\"cholesterol\", \"heart_rate\") )  cor_pca <- ds.vertCor(\"D_aligned\", pca_vars, datasources = connections) pca_dist <- ds.vertPCA(cor_result = cor_pca, n_components = 5) pca_dist"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"distributed-glms","dir":"Articles","previous_headings":"Scenario 2: Distributed Analysis","what":"Distributed GLMs","title":"Validation","text":"Distributed Gaussian coefficients: Distributed Binomial coefficients: Distributed Poisson coefficients:","code":"x_vars <- list(   server1 = c(\"age\", \"bmi\"),   server2 = c(\"glucose\"),   server3 = c(\"cholesterol\", \"heart_rate\") )  model_gaussian <- ds.vertGLM(   \"D_aligned\",   y_var = \"bp\",   x_vars = x_vars,   y_server = \"server2\",   family = \"gaussian\",   datasources = connections ) round(coef(model_gaussian), 4) model_binomial <- ds.vertGLM(   \"D_aligned\",   y_var = \"hypertension\",   x_vars = x_vars,   y_server = \"server2\",   family = \"binomial\",   datasources = connections ) round(coef(model_binomial), 4) model_poisson <- ds.vertGLM(   \"D_aligned\",   y_var = \"visits\",   x_vars = x_vars,   y_server = \"server2\",   family = \"poisson\",   datasources = connections ) round(coef(model_poisson), 4)"},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"correlation-comparison","dir":"Articles","previous_headings":"Comparison","what":"Correlation Comparison","title":"Validation","text":"Within-server correlations computed plaintext therefore exact. Cross-server correlations computed via MHE threshold decryption using CKKS approximate encryption scheme. following table compares key cross-server pairs. Maximum absolute error: 0.0001. Within-server correlations exact; cross-server differences arise CKKS approximate arithmetic.","code":"diff_cor <- local_cor - cor_dist$correlation[rownames(local_cor), colnames(local_cor)] round(diff_cor, 4)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"pca-comparison","dir":"Articles","previous_headings":"Comparison","what":"PCA Comparison","title":"Validation","text":"PCA computed via eigen decomposition correlation matrix, errors propagated correlation differences. Maximum absolute eigenvalue difference approximately 10^-4.","code":"data.frame(   Component = paste0(\"PC\", 1:5),   Local = round(local_pca$sdev^2, 4),   Distributed = round(pca_dist$eigenvalues, 4),   Difference = round(local_pca$sdev^2 - pca_dist$eigenvalues, 4) )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"glm-comparison","dir":"Articles","previous_headings":"Comparison","what":"GLM Comparison","title":"Validation","text":"GLM family, coefficients local fit distributed fit compared. distributed GLM uses Block Coordinate Descent L2 regularisation (lambda = 1e-4), introduces small systematic bias toward zero. Gaussian: Binomial: Poisson:","code":"data.frame(   Coefficient = names(coef(fit_gaussian)),   Local = round(coef(fit_gaussian), 4),   Distributed = round(coef(model_gaussian), 4),   Difference = round(coef(fit_gaussian) - coef(model_gaussian), 4) ) data.frame(   Coefficient = names(coef(fit_binomial)),   Local = round(coef(fit_binomial), 4),   Distributed = round(coef(model_binomial), 4),   Difference = round(coef(fit_binomial) - coef(model_binomial), 4) ) data.frame(   Coefficient = names(coef(fit_poisson)),   Local = round(coef(fit_poisson), 4),   Distributed = round(coef(model_poisson), 4),   Difference = round(coef(fit_poisson) - coef(model_poisson), 4) )"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"error-summary","dir":"Articles","previous_headings":"","what":"Error Summary","title":"Validation","text":"distributed results match local R analysis high accuracy. Small differences arise three independent sources: CKKS approximation error ‚Äì homomorphic encryption scheme used cross-server correlation encodes real numbers finite precision. default log_scale = 40, individual operations carry approximately 12 decimal digits precision, accumulation additions inner product results final errors around 10^-4 typical sample sizes. L2 regularisation ‚Äì BCD algorithm adds small ridge penalty (lambda = 1e-4) diagonal block‚Äôs cross-product matrix. prevents singular near-singular systems iterative updates introduces small systematic bias toward zero. BCD convergence tolerance ‚Äì iterative solver terminates relative change coefficients falls threshold, leaving residual optimisation error negligible practice.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/d-validation.html","id":"cleanup","dir":"Articles","previous_headings":"","what":"Cleanup","title":"Validation","text":"","code":"datashield.logout(connections)"},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Security Model","text":"dsVertClient uses Multiparty Homomorphic Encryption (MHE) based CKKS scheme protect data distributed computation. vignette describes threat model, participant learns, security guarantees.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"threat-model","dir":"Articles","previous_headings":"","what":"Threat Model","title":"Security Model","text":"protocol assumes semi-honest (honest--curious) adversary model: parties follow protocol correctly Parties may attempt infer information messages receive party intentionally sends corrupted data deviates protocol standard model federated analytics healthcare research settings, institutions contractually obligated follow protocols may curious others‚Äô data.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"correlation-analysis","dir":"Articles","previous_headings":"What MHE Protects","what":"Correlation Analysis","title":"Security Model","text":"distributed correlation, cross-server products computed encrypted data. server encrypts standardized columns collective public key (CPK). single server can decrypt ciphertexts.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"glm-with-encrypted-labels","dir":"Articles","previous_headings":"What MHE Protects","what":"GLM with Encrypted Labels","title":"Security Model","text":"response variable y never leaves label server plaintext. Non-label servers compute gradient contributions using encrypted y.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"what-the-client-sees","dir":"Articles","previous_headings":"","what":"What the Client Sees","title":"Security Model","text":"client (researcher coordinating analysis) receives: Collective Public Key (CPK) ‚Äì decrypt anything alone Encrypted ciphertexts ‚Äì opaque blobs, undecryptable without K secret key shares Partial decryption shares ‚Äì share individually reveals nothing Final aggregated results ‚Äì correlation coefficients, GLM coefficients, deviance client see: Individual-level data server Raw feature values Response variable values Residuals per-observation predictions","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"threshold-property","dir":"Articles","previous_headings":"","what":"Threshold Property","title":"Security Model","text":"Decryption requires cooperation K parties. collective secret key additively shared: sk=sk1+sk2+‚Ä¶+skKsk = sk_1 + sk_2 + \\ldots + sk_K party k computes partial decryption share using sk_k. K shares combined can ciphertext decrypted. K--K threshold scheme: every party must participate.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"collusion-resistance","dir":"Articles","previous_headings":"","what":"Collusion Resistance","title":"Security Model","text":"Even K-1 servers collude (share secret key shares), decrypt ciphertext without remaining server‚Äôs share. RLWE assumption guarantees partial information K-1 shares computationally indistinguishable random noise. Example 3 servers: Servers 1 2 collude: hold sk_1 + sk_2, need sk_3 Servers 1 3 collude: hold sk_1 + sk_3, need sk_2 3 cooperate: sk_1 + sk_2 + sk_3 = sk, decryption succeeds","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"what-is-revealed","dir":"Articles","previous_headings":"","what":"What IS Revealed","title":"Security Model","text":"following aggregate statistics revealed client: summary statistics n observations. directly reveal individual data points. However, statistical release, care taken small samples highly identifying variable combinations.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"psi-alignment-security","dir":"Articles","previous_headings":"","what":"PSI Alignment Security","title":"Security Model","text":"Record alignment uses ECDH-based Private Set Intersection (PSI) protocol. server holds secret P-256 scalar never leaves server. protocol following security properties:","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"dictionary-attack-resistance","dir":"Articles","previous_headings":"PSI Alignment Security","what":"Dictionary Attack Resistance","title":"Security Model","text":"Unlike SHA-256 hashing, attacker obtains hash list can pre-compute hashes dictionary plausible identifiers match , ECDH-PSI masks identifier server-held secret scalar. Without knowledge scalar, masked curve points computationally indistinguishable random group elements. attacker intercepts masked points mount dictionary attack reproduce server‚Äôs scalar multiplication.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"server-scalar-confidentiality","dir":"Articles","previous_headings":"PSI Alignment Security","what":"Server Scalar Confidentiality","title":"Security Model","text":"server kk draws secret scalar Œ±k\\alpha_k uniformly random P-256 curve order. scalar generated stored exclusively server. never transmitted client servers. masked points Œ±k‚ãÖH(id)\\alpha_k \\cdot H(\\text{id}) one-way elliptic-curve discrete logarithm assumption: given masked point, recovering Œ±k\\alpha_k computationally infeasible.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"unlinkability-across-servers-ddh","dir":"Articles","previous_headings":"PSI Alignment Security","what":"Unlinkability Across Servers (DDH)","title":"Security Model","text":"client receives doubly-masked points server pair. Decisional Diffie‚ÄìHellman (DDH) assumption P-256, client link singly-masked point server AA corresponding singly-masked point server BB. client can determine whether two doubly-masked points (one direction) correspond identifier, exactly information needed alignment nothing .","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"non-matching-identifier-privacy","dir":"Articles","previous_headings":"PSI Alignment Security","what":"Non-Matching Identifier Privacy","title":"Security Model","text":"party learns identifiers held servers absent dataset. intersection protocol reveals set common identifiers (masked form). Identifiers present server AA absent server BB produce masked points match doubly-masked output, client simply discards without learning anything underlying identifier values.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/articles/e-security.html","id":"assumptions-and-limitations","dir":"Articles","previous_headings":"","what":"Assumptions and Limitations","title":"Security Model","text":"Semi-honest model: Parties assumed follow protocol correctly. malicious party send corrupted key shares ciphertexts. Verifiable computation implemented. RLWE hardness: Security relies Ring Learning Errors problem computationally hard. RLWE leading candidate post-quantum cryptography. Network security: protocol assumes secure (TLS) communication channels client servers. DataSHIELD/Opal provides via HTTPS. Aggregate leakage: revealed aggregate statistics (correlations, coefficients) theoretically allow inference individuals sample small variables quasi-identifiers. inherent statistical release, specific MHE. differential privacy: protocol provides cryptographic protection intermediate computations add noise final outputs. Combining MHE differential privacy possible currently implemented.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Sarrat Gonz√°lez. Author, maintainer. Miron Banjac. Author. Juan R Gonz√°lez. Author.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sarrat Gonz√°lez D, Banjac M, Gonz√°lez J (2026). dsVertClient: DataSHIELD Client Functions Vertically Partitioned Data. R package version 1.4.0, https://github.com/isglobal-brge/dsVertClient.","code":"@Manual{,   title = {dsVertClient: DataSHIELD Client Functions for Vertically Partitioned Data},   author = {David {Sarrat Gonz√°lez} and Miron Banjac and Juan R Gonz√°lez},   year = {2026},   note = {R package version 1.4.0},   url = {https://github.com/isglobal-brge/dsVertClient}, }"},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"dsVertClient","text":"dsVertClient client-side DataSHIELD package enables privacy-preserving statistical analysis vertically partitioned federated data. vertical partitioning, different data sources hold different variables (columns) set observations (rows). package provides user-friendly functions : ECDH-PSI Record Alignment: Privacy-preserving record matching using P-256 elliptic curves (dictionary attacks possible) Correlation Analysis: Compute correlation matrices using Multiparty Homomorphic Encryption (MHE) threshold decryption Principal Component Analysis: Perform PCA MHE-based correlation matrix Generalized Linear Models: Fit GLMs using Block Coordinate Descent encrypted labels (5 families)","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"dsVertClient","text":"","code":"# Install from GitHub (install dsVert first on servers) devtools::install_github(\"isglobal-brge/dsVertClient\")"},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"dsVertClient","text":"","code":"library(dsVertClient) library(DSI)  # Connect to Opal/DataSHIELD servers conns <- datashield.login(logindata)  # 1. Align records across servers using ECDH-PSI ds.psiAlign(\"D\", \"patient_id\", \"D_aligned\", datasources = conns)  # 2. Define which variables are on which server variables <- list(   hospital_A = c(\"age\", \"bmi\"),   hospital_B = c(\"glucose\", \"systolic_bp\"),   hospital_C = c(\"cholesterol\", \"hdl\") )  # 3. Compute correlation matrix (MHE with threshold decryption) cor_result <- ds.vertCor(\"D_aligned\", variables, datasources = conns) print(cor_result)  # 4. Perform PCA pca <- ds.vertPCA(\"D_aligned\", variables, n_components = 3, datasources = conns) print(pca)  # 5. Fit a GLM model <- ds.vertGLM(\"D_aligned\", \"outcome\", variables,                     y_server = \"hospital_B\", family = \"gaussian\",                     datasources = conns) summary(model)  # Disconnect datashield.logout(conns)"},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"workflow-align--analyze","dir":"","previous_headings":"","what":"Workflow: Align ‚Üí Analyze","title":"dsVertClient","text":"","code":"‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ  ds.psiAlign     ‚îÇ‚îÄ‚îÄ‚ñ∂‚îÇ        Analyze            ‚îÇ  ‚îÇ  (ECDH-PSI)      ‚îÇ   ‚îÇ  ds.vertCor (MHE)         ‚îÇ  ‚îÇ                   ‚îÇ   ‚îÇ  ds.vertPCA               ‚îÇ  ‚îÇ                   ‚îÇ   ‚îÇ  ds.vertGLM (BCD + MHE)   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"mhe-correlation-how-it-works","dir":"","previous_headings":"","what":"MHE Correlation: How It Works","title":"dsVertClient","text":"6-phase threshold MHE protocol: Key Generation: server generates secret key share public key share. Party 0 creates Common Reference Polynomial (CRP). Key Combination: Public key shares combined Collective Public Key (CPK). Encryption CPK requires servers decryption. Encryption: server standardizes data (Z-scores) encrypts columns CPK. Local Correlation: Within-server correlations computed plaintext. Cross-Server Correlation: server pair (, B): server computes Z_A * Enc(Z_B) homomorphically. server provides partial decryption share. client fuses shares recover inner product. Assembly: full p x p correlation matrix assembled local cross-server blocks.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"requirements","dir":"","previous_headings":"","what":"Requirements","title":"dsVertClient","text":"R >= 4.0.0 DSI package jsonlite package dsVert package installed DataSHIELD servers (Opal/Rock)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"dsVertClient","text":"Getting Started: Setup, PSI record alignment, first analysis Statistical Analysis: Correlation, PCA, GLMs Methodology: MHE protocol, BCD-IRLS, ECDH-PSI details Validation: Numerical comparison local R Security Model: Threat model, MHE guarantees, PSI security","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"authors","dir":"","previous_headings":"","what":"Authors","title":"dsVertClient","text":"David Sarrat Gonzalez Miron Banjac Juan R Gonzalez","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"dsVertClient","text":"De Cristofaro, E. & Tsudik, G. (2010). ‚ÄúPractical Private Set Intersection Protocols Linear Complexity‚Äù. FC 2010. Mouchet, C. et al.¬†(2021). ‚ÄúMultiparty Homomorphic Encryption Ring-Learning--Errors‚Äù. Proceedings Privacy Enhancing Technologies (PETS). Cheon, J.H. et al.¬†(2017). ‚ÄúHomomorphic Encryption Arithmetic Approximate Numbers‚Äù. ASIACRYPT 2017. van Kesteren, E.J. et al.¬†(2019). ‚ÄúPrivacy-preserving generalized linear models using distributed block coordinate descent‚Äù. arXiv:1911.03183. Lattigo v6: https://github.com/tuneinsight/lattigo","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/coef.ds.glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients Method for ds.glm Objects ‚Äî coef.ds.glm","title":"Coefficients Method for ds.glm Objects ‚Äî coef.ds.glm","text":"Extract coefficients ds.glm object.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/coef.ds.glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients Method for ds.glm Objects ‚Äî coef.ds.glm","text":"","code":"# S3 method for class 'ds.glm' coef(object, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/coef.ds.glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients Method for ds.glm Objects ‚Äî coef.ds.glm","text":"object ds.glm object ... Additional arguments (ignored)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/coef.ds.glm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coefficients Method for ds.glm Objects ‚Äî coef.ds.glm","text":"Named numeric vector coefficients","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":null,"dir":"Reference","previous_headings":"","what":"Align Records Across Servers (Deprecated) ‚Äî ds.alignRecords","title":"Align Records Across Servers (Deprecated) ‚Äî ds.alignRecords","text":"Deprecated: Use ds.psiAlign instead. Client-side function aligns records DataSHIELD servers match reference set hashed identifiers. ensures observations properly matched across vertically partitioned data.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align Records Across Servers (Deprecated) ‚Äî ds.alignRecords","text":"","code":"ds.alignRecords(   data_name,   id_col,   reference_hashes,   newobj = \"D_aligned\",   algo = \"sha256\",   datasources = NULL )"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align Records Across Servers (Deprecated) ‚Äî ds.alignRecords","text":"data_name Character string. Name data frame server. id_col Character string. Name identifier column. reference_hashes Character vector. Hashes reference server (obtained via ds.hashId). newobj Character string. Name aligned data frame servers. Default \"D_aligned\". algo Character string. Hash algorithm (must match reference). Default \"sha256\". datasources DataSHIELD connection object list connections. NULL, uses available connections.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align Records Across Servers (Deprecated) ‚Äî ds.alignRecords","text":"Invisibly returns list alignment statistics server: n_matched: Number records matched n_reference: Number reference hashes","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Align Records Across Servers (Deprecated) ‚Äî ds.alignRecords","text":"Deprecated: function uses SHA-256 hash-based alignment. client receives raw SHA-256 hashes patient identifiers, vulnerable dictionary attacks IDs predictable. Use ds.psiAlign instead, provides ECDH-PSI alignment client sees opaque elliptic curve points. function performs record alignment vertically partitioned data: Takes reference hashes (ds.hashId one server) target server: Hashes local identifiers Matches reference hashes Reorders data match reference order Creates new aligned data frame alignment, servers : number observations Observations order (identifier) observations present partitions","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.alignRecords.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Align Records Across Servers (Deprecated) ‚Äî ds.alignRecords","text":"","code":"if (FALSE) { # \\dontrun{ # Step 1: Get reference hashes from first server ref <- ds.hashId(\"D\", \"patient_id\", datasource = conns$server1)  # Step 2: Align all servers (including reference) to these hashes ds.alignRecords(\"D\", \"patient_id\", ref$hashes,                 newobj = \"D_aligned\", datasources = conns)  # Now \"D_aligned\" on all servers has matching, ordered observations } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":null,"dir":"Reference","previous_headings":"","what":"Hash Identifier Column (Deprecated) ‚Äî ds.hashId","title":"Hash Identifier Column (Deprecated) ‚Äî ds.hashId","text":"Deprecated: Use ds.psiAlign instead. Client-side function retrieves hashed identifiers DataSHIELD server. Used first step record matching vertically partitioned data.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hash Identifier Column (Deprecated) ‚Äî ds.hashId","text":"","code":"ds.hashId(data_name, id_col, algo = \"sha256\", datasource = NULL)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hash Identifier Column (Deprecated) ‚Äî ds.hashId","text":"data_name Character string. Name data frame server. id_col Character string. Name identifier column hash. algo Character string. Hash algorithm. Default \"sha256\". datasource DataSHIELD connection object (DSConnection). NULL, uses first available connection.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hash Identifier Column (Deprecated) ‚Äî ds.hashId","text":"list containing: hashes: Character vector hashed identifiers n: Number observations","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hash Identifier Column (Deprecated) ‚Äî ds.hashId","text":"Deprecated: function uses SHA-256 hashing, vulnerable dictionary attacks identifiers predictable (e.g. sequential patient IDs). Use ds.psiAlign instead, provides ECDH-PSI alignment stronger privacy guarantees: client sees opaque elliptic curve points reversed identifiers. function typically called \"reference\" server vertical partitioning scenario. returned hashes passed ds.alignRecords servers align data.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.hashId.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hash Identifier Column (Deprecated) ‚Äî ds.hashId","text":"","code":"if (FALSE) { # \\dontrun{ # Get hashes from reference server ref_hashes <- ds.hashId(\"D\", \"patient_id\", datasource = conns$server1)  # Use hashes to align other servers ds.alignRecords(\"D\", \"patient_id\", ref_hashes$hashes,                 datasources = conns[c(\"server2\", \"server3\")]) } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.psiAlign.html","id":null,"dir":"Reference","previous_headings":"","what":"ECDH-PSI Record Alignment ‚Äî ds.psiAlign","title":"ECDH-PSI Record Alignment ‚Äî ds.psiAlign","text":"Privacy-preserving record alignment using Elliptic Curve Diffie-Hellman Private Set Intersection (ECDH-PSI). Aligns data frames across vertically partitioned DataSHIELD servers rows correspond individuals, without exposing identifiers.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.psiAlign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ECDH-PSI Record Alignment ‚Äî ds.psiAlign","text":"","code":"ds.psiAlign(   data_name,   id_col,   newobj = \"D_aligned\",   ref_server = NULL,   datasources = NULL )"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.psiAlign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ECDH-PSI Record Alignment ‚Äî ds.psiAlign","text":"data_name Character string. Name data frame server. id_col Character string. Name identifier column. newobj Character string. Name aligned data frame servers. Default \"D_aligned\". ref_server Character string NULL. Name reference server. NULL (default), first connection used. datasources DataSHIELD connection object list connections. NULL, uses available connections.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.psiAlign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ECDH-PSI Record Alignment ‚Äî ds.psiAlign","text":"Invisibly returns list alignment statistics server: n_matched: Number records matched n_total: Number records server","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.psiAlign.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ECDH-PSI Record Alignment ‚Äî ds.psiAlign","text":"function replaces ds.hashId + ds.alignRecords single call provides stronger privacy guarantees.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.psiAlign.html","id":"protocol-overview","dir":"Reference","previous_headings":"","what":"Protocol overview","title":"ECDH-PSI Record Alignment ‚Äî ds.psiAlign","text":"ECDH-PSI exploits commutativity elliptic curve scalar multiplication: \\(\\alpha \\cdot (\\beta \\cdot H(id)) = \\beta \\cdot (\\alpha \\cdot H(id))\\). reference server hashes IDs P-256 curve points multiplies random scalar \\(\\alpha\\). Returns masked points client. target server: target generates scalar \\(\\beta\\), double-masks ref points \\(\\beta\\) (stores locally), masks IDs \\(\\beta\\). reference double-masks target points \\(\\alpha\\). target matches double-masked sets find intersection, reorders data match reference order. multi-server intersection ensures records present servers retained.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.psiAlign.html","id":"security-ddh-assumption-on-p-","dir":"Reference","previous_headings":"","what":"Security (DDH assumption on P-256)","title":"ECDH-PSI Record Alignment ‚Äî ds.psiAlign","text":"client sees opaque elliptic curve points ‚Äî reversible identifiers, vulnerable dictionary attacks. server's scalar never leaves server. DDH assumption prevents client linking single-masked points across servers.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.psiAlign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ECDH-PSI Record Alignment ‚Äî ds.psiAlign","text":"","code":"if (FALSE) { # \\dontrun{ # Align records across all servers using PSI ds.psiAlign(\"D\", \"patient_id\", \"D_aligned\", datasources = connections)  # Now \"D_aligned\" on all servers has matching, ordered observations } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Identifier Format Across Servers ‚Äî ds.validateIdFormat","title":"Validate Identifier Format Across Servers ‚Äî ds.validateIdFormat","text":"Client-side function validates identifier format consistency across DataSHIELD servers record alignment.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Identifier Format Across Servers ‚Äî ds.validateIdFormat","text":"","code":"ds.validateIdFormat(data_name, id_col, pattern = NULL, datasources = NULL)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Identifier Format Across Servers ‚Äî ds.validateIdFormat","text":"data_name Character string. Name data frame server. id_col Character string. Name identifier column. pattern Character string (optional). Regular expression pattern IDs match servers. datasources DataSHIELD connection object(s). NULL, uses available connections.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Identifier Format Across Servers ‚Äî ds.validateIdFormat","text":"list class \"ds.id.validation\" containing: valid: Logical, TRUE formats consistent across servers servers: Data frame validation results per server format_match: Logical, TRUE servers format signature pattern_match: Logical, TRUE servers match pattern (pattern provided) warnings: Character vector warnings detected","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate Identifier Format Across Servers ‚Äî ds.validateIdFormat","text":"function called ds.alignRecords ensure identifier formats consistent across data partitions. helps catch common issues like: Different ID formats (e.g., \"001\" vs \"1\" vs \"ID001\") Missing duplicate identifiers Type mismatches (numeric vs character) function uses format signatures (hashed format characteristics) compare formats without revealing actual identifier values.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.validateIdFormat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate Identifier Format Across Servers ‚Äî ds.validateIdFormat","text":"","code":"if (FALSE) { # \\dontrun{ # Validate ID format before alignment validation <- ds.validateIdFormat(\"D\", \"patient_id\", datasources = conns) print(validation)  if (validation$valid) {   # Proceed with alignment   ref_hashes <- ds.hashId(\"D\", \"patient_id\", datasource = conns[\"server1\"])   ds.alignRecords(\"D\", \"patient_id\", ref_hashes$hashes, \"D_aligned\", conns) }  # With pattern validation validation <- ds.validateIdFormat(\"D\", \"patient_id\",                                   pattern = \"^[A-Z]{2}[0-9]{6}$\",                                   datasources = conns) } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":null,"dir":"Reference","previous_headings":"","what":"Privacy-Preserving Correlation for Vertically Partitioned Data ‚Äî ds.vertCor","title":"Privacy-Preserving Correlation for Vertically Partitioned Data ‚Äî ds.vertCor","text":"Computes Pearson correlation matrix vertically partitioned data using Multiparty Homomorphic Encryption (MHE) threshold decryption.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Privacy-Preserving Correlation for Vertically Partitioned Data ‚Äî ds.vertCor","text":"","code":"ds.vertCor(   data_name,   variables,   log_n = 12,   log_scale = 40,   datasources = NULL )"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Privacy-Preserving Correlation for Vertically Partitioned Data ‚Äî ds.vertCor","text":"data_name Character string. Name (aligned) data frame server. variables named list name corresponds server name element character vector variable names server. log_n Integer. CKKS ring dimension parameter (12, 13, 14). Controls number slots: N/2 = 2^(logN-1). Default 12 (2048 slots, fast). Use 13 14 larger datasets. log_scale Integer. CKKS scale parameter controlling precision. Default 40 (approximately 12 decimal digits precision). datasources DataSHIELD connection object list connections. NULL, uses available connections.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Privacy-Preserving Correlation for Vertically Partitioned Data ‚Äî ds.vertCor","text":"list class \"ds.cor\" containing: correlation: full correlation matrix (p x p) var_names: Variable names order n_obs: Number observations method: \"MHE-CKKS-Threshold\" indicating method used servers: Names servers involved local_correlations: List within-server correlation matrices cross_correlations: List cross-server correlation matrices mhe_params: List log_n log_scale used","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"threshold-mhe-protocol-phases-","dir":"Reference","previous_headings":"","what":"Threshold MHE Protocol (6 phases)","title":"Privacy-Preserving Correlation for Vertically Partitioned Data ‚Äî ds.vertCor","text":"function implements full multiparty homomorphic encryption protocol threshold decryption: Key Generation: server generates secret key share public key share. Party 0 also generates Common Reference Polynomial (CRP) shared parties. Key Combination: Public key shares combined Collective Public Key (CPK). Data encrypted CPK can decrypted servers cooperating. Encryption: server standardizes columns (Z-scores) encrypts column--column CPK. Local Correlation: Within-server correlations computed plaintext (encryption needed data stays -server). Cross-Server Correlation: pair servers (, B), server receives Enc(Z_B) computes element-wise product Z_A * Enc(Z_B) homomorphically. result still encrypted requires threshold decryption. server produces partial decryption share, client fuses shares recover inner product. Assembly: client assembles full p x p correlation matrix local correlations (diagonal blocks) cross-server correlations (-diagonal blocks).","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"security-guarantees","dir":"Reference","previous_headings":"","what":"Security Guarantees","title":"Privacy-Preserving Correlation for Vertically Partitioned Data ‚Äî ds.vertCor","text":"Client privacy client (researcher) decrypt individual data. receives partial decryption shares useless alone. final aggregate statistics (correlation coefficients) revealed fusing shares. Server privacy server's raw data never leaves server. servers see encrypted columns (opaque ciphertexts). Collusion resistance Even K-1 colluding servers decrypt without K-th server's key share. Full decryption requires cooperation K servers.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"performance-notes","dir":"Reference","previous_headings":"","what":"Performance Notes","title":"Privacy-Preserving Correlation for Vertically Partitioned Data ‚Äî ds.vertCor","text":"log_n = 12: 2048 observations, fastest log_n = 13: 4096 observations log_n = 14: 8192 observations, slowest Precision: approximately 10^-3 10^-4 error due CKKS approximation dominant cost threshold decryption loop (Phase 5), requires one round-trip per server per cross-correlation element.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Privacy-Preserving Correlation for Vertically Partitioned Data ‚Äî ds.vertCor","text":"Mouchet, C. et al. (2021). \"Multiparty Homomorphic Encryption Ring-Learning--Errors\". Proceedings Privacy Enhancing Technologies (PETS). Cheon, J.H. et al. (2017). \"Homomorphic Encryption Arithmetic Approximate Numbers\". ASIACRYPT 2017.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertCor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Privacy-Preserving Correlation for Vertically Partitioned Data ‚Äî ds.vertCor","text":"","code":"if (FALSE) { # \\dontrun{ # Connect to Opal/DataSHIELD servers connections <- DSI::datashield.login(builder$build())  # Align records across servers using ECDH-PSI ds.psiAlign(\"D\", \"patient_id\", \"D_aligned\", datasources = connections)  # Define which variables are on which server vars <- list(   hospital_A = c(\"age\", \"bmi\"),   hospital_B = c(\"glucose\", \"systolic_bp\") )  # Compute privacy-preserving correlation result <- ds.vertCor(\"D_aligned\", vars, datasources = connections) print(result) } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Linear Model for Vertically Partitioned Data ‚Äî ds.vertGLM","title":"Generalized Linear Model for Vertically Partitioned Data ‚Äî ds.vertGLM","text":"Client-side function fits Generalized Linear Model across vertically partitioned data using Block Coordinate Descent encrypted labels. response variable y needs exist ONE server (\"label server\"). Non-label servers compute gradient updates using y encrypted MHE collective public key, aggregated p_k-length gradient revealed via threshold decryption.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Linear Model for Vertically Partitioned Data ‚Äî ds.vertGLM","text":"","code":"ds.vertGLM(   data_name,   y_var,   x_vars,   y_server = NULL,   family = \"gaussian\",   max_iter = 100,   tol = 1e-04,   lambda = 1e-04,   log_n = 12,   log_scale = 40,   verbose = TRUE,   datasources = NULL )"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Linear Model for Vertically Partitioned Data ‚Äî ds.vertGLM","text":"data_name Character string. Name (aligned) data frame server. y_var Character string. Name response variable (must exist label server specified y_server). x_vars named list name corresponds server name element character vector predictor variable names server. y_server Character string. Name server holding response variable. server uses plaintext IRLS; servers use encrypted gradient protocol. family Character string. GLM family: \"gaussian\", \"binomial\", \"poisson\", \"Gamma\", \"inverse.gaussian\". Default \"gaussian\". max_iter Integer. Maximum number BCD iterations. Default 100. tol Numeric. Convergence tolerance coefficient change. Default 1e-4 (accounts CKKS approximation noise). lambda Numeric. L2 regularization parameter. Default 1e-4. log_n Integer. CKKS ring dimension parameter (12, 13, 14). Default 12 (2048 slots, supports 2048 observations). log_scale Integer. CKKS scale parameter. Default 40. verbose Logical. Print progress messages. Default TRUE. datasources DataSHIELD connection object list connections. NULL, uses available connections.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Linear Model for Vertically Partitioned Data ‚Äî ds.vertGLM","text":"list class \"ds.glm\" containing: coefficients: Named vector coefficient estimates (original scale, including intercept) iterations: Number iterations convergence converged: Logical indicating convergence family: Family used n_obs: Number observations n_vars: Number predictor variables (including intercept) lambda: Regularization parameter used deviance: Residual deviance fitted model null_deviance: Null deviance (intercept-model) pseudo_r2: McFadden's pseudo R-squared aic: Akaike Information Criterion y_server: Name label server call: matched call","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"feature-standardization","dir":"Reference","previous_headings":"","what":"Feature Standardization","title":"Generalized Linear Model for Vertically Partitioned Data ‚Äî ds.vertGLM","text":"Features automatically standardized (centered scaled) server BCD ensure fast convergence. Gaussian family, response also standardized. Coefficients transformed back original scale convergence, intercept computed.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"encrypted-label-bcd-irls-protocol","dir":"Reference","previous_headings":"","what":"Encrypted-Label BCD-IRLS Protocol","title":"Generalized Linear Model for Vertically Partitioned Data ‚Äî ds.vertGLM","text":"response variable y resides single \"label server\". Non-label servers never see y plaintext. protocol proceeds : MHE Key Setup: servers generate key shares combine Collective Public Key (CPK) Galois keys. Standardize: server standardizes features. Encrypt y: label server encrypts (standardized) y CPK distributes ciphertext non-label servers. BCD Loop: iteration, server updates block coefficients standardized scale. Unstandardize: Coefficients transformed back original scale intercept computed. Deviance: Computed label server using plaintext y final linear predictor (original scale).","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized Linear Model for Vertically Partitioned Data ‚Äî ds.vertGLM","text":"van Kesteren, E.J. et al. (2019). Privacy-preserving generalized linear models using distributed block coordinate descent. arXiv:1911.03183. Mouchet, C. et al. (2021). \"Multiparty Homomorphic Encryption Ring-Learning--Errors\". Proceedings Privacy Enhancing Technologies.","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertGLM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Linear Model for Vertically Partitioned Data ‚Äî ds.vertGLM","text":"","code":"if (FALSE) { # \\dontrun{ x_vars <- list(   server1 = c(\"age\", \"bmi\"),   server2 = c(\"glucose\"),   server3 = c(\"cholesterol\", \"heart_rate\") )  # Gaussian GLM (bp on server2) model <- ds.vertGLM(\"D_aligned\", \"bp\", x_vars,                      y_server = \"server2\", family = \"gaussian\") print(model) } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":null,"dir":"Reference","previous_headings":"","what":"Principal Component Analysis for Vertically Partitioned Data ‚Äî ds.vertPCA","title":"Principal Component Analysis for Vertically Partitioned Data ‚Äî ds.vertPCA","text":"Performs PCA vertically partitioned data using privacy-preserving correlation matrix computed via Homomorphic Encryption.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Principal Component Analysis for Vertically Partitioned Data ‚Äî ds.vertPCA","text":"","code":"ds.vertPCA(   data_name = NULL,   variables = NULL,   n_components = NULL,   cor_result = NULL,   log_n = 12,   log_scale = 40,   datasources = NULL )"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Principal Component Analysis for Vertically Partitioned Data ‚Äî ds.vertPCA","text":"data_name Character string. Name (aligned) data frame server. Ignored cor_result provided. variables named list name corresponds server name element character vector variable names server. Ignored cor_result provided. n_components Integer. Number principal components return. Default NULL (returns ). cor_result existing ds.cor object ds.vertCor. provided, MHE protocol re-run; PCA computed directly correlation matrix. avoids running expensive MHE protocol twice already correlation. log_n Integer. CKKS ring dimension parameter MHE. Default 12. Ignored cor_result provided. log_scale Integer. CKKS precision parameter MHE. Default 40. Ignored cor_result provided. datasources DataSHIELD connection object list connections. NULL, uses available connections. Ignored cor_result provided.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Principal Component Analysis for Vertically Partitioned Data ‚Äî ds.vertPCA","text":"list class \"ds.pca\" containing: loadings: Matrix variable loadings (n_vars x n_components) eigenvalues: Eigenvalues component variance_pct: Percentage variance explained cumulative_pct: Cumulative percentage explained var_names: Variable names n_obs: Number observations correlation: correlation matrix used PCA","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Principal Component Analysis for Vertically Partitioned Data ‚Äî ds.vertPCA","text":"function performs PCA using correlation matrix obtained via Multiparty Homomorphic Encryption (MHE). approach : Compute privacy-preserving correlation matrix using ds.vertCor (reuse existing one via cor_result parameter) Perform eigen decomposition correlation matrix Extract loadings (eigenvectors) eigenvalues Since PCA standardized data equivalent eigen decomposition correlation matrix, gives correct loadings variance explained. Note scores: function return principal component scores computing scores require access raw data. need scores, need compute server using loadings aggregate results (separate operation).","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"interpreting-loadings","dir":"Reference","previous_headings":"","what":"Interpreting Loadings","title":"Principal Component Analysis for Vertically Partitioned Data ‚Äî ds.vertPCA","text":"column loadings matrix represents principal component. values show much variable contributes component: Values close 1 -1 indicate strong contribution Values close 0 indicate weak contribution Sign indicates direction relationship","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"security","dir":"Reference","previous_headings":"","what":"Security","title":"Principal Component Analysis for Vertically Partitioned Data ‚Äî ds.vertPCA","text":"function inherits security properties ds.vertCor: Individual observations never exposed client decrypt without servers cooperating aggregate statistics (correlation matrix) revealed","code":""},{"path":[]},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/ds.vertPCA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Principal Component Analysis for Vertically Partitioned Data ‚Äî ds.vertPCA","text":"","code":"if (FALSE) { # \\dontrun{ vars <- list(   server1 = c(\"age\", \"weight\"),   server2 = c(\"height\", \"bmi\") )  pca_result <- ds.vertPCA(\"D_aligned\", vars, n_components = 3)  # Or reuse an existing correlation result (avoids running MHE again): cor_result <- ds.vertCor(\"D_aligned\", vars) pca_result <- ds.vertPCA(cor_result = cor_result, n_components = 3)  # View variance explained print(pca_result)  # Biplot of loadings for first two PCs plot(pca_result$loadings[, 1], pca_result$loadings[, 2],      xlim = c(-1, 1), ylim = c(-1, 1),      xlab = paste0(\"PC1 (\", round(pca_result$variance_pct[1], 1), \"%)\"),      ylab = paste0(\"PC2 (\", round(pca_result$variance_pct[2], 1), \"%)\")) text(pca_result$loadings[, 1], pca_result$loadings[, 2],      labels = pca_result$var_names, pos = 3) abline(h = 0, v = 0, lty = 2) } # }"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.cor.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for ds.cor Objects ‚Äî print.ds.cor","title":"Print Method for ds.cor Objects ‚Äî print.ds.cor","text":"Prints summary correlation results.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for ds.cor Objects ‚Äî print.ds.cor","text":"","code":"# S3 method for class 'ds.cor' print(x, digits = 4, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for ds.cor Objects ‚Äî print.ds.cor","text":"x ds.cor object digits Number digits display ... Additional arguments (ignored)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for ds.glm Objects ‚Äî print.ds.glm","title":"Print Method for ds.glm Objects ‚Äî print.ds.glm","text":"Prints summary GLM results.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for ds.glm Objects ‚Äî print.ds.glm","text":"","code":"# S3 method for class 'ds.glm' print(x, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for ds.glm Objects ‚Äî print.ds.glm","text":"x ds.glm object ... Additional arguments (ignored)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.id.validation.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for ds.id.validation Objects ‚Äî print.ds.id.validation","title":"Print Method for ds.id.validation Objects ‚Äî print.ds.id.validation","text":"Prints summary ID format validation results.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.id.validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for ds.id.validation Objects ‚Äî print.ds.id.validation","text":"","code":"# S3 method for class 'ds.id.validation' print(x, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.id.validation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for ds.id.validation Objects ‚Äî print.ds.id.validation","text":"x ds.id.validation object ... Additional arguments (ignored)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.pca.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for ds.pca Objects ‚Äî print.ds.pca","title":"Print Method for ds.pca Objects ‚Äî print.ds.pca","text":"Prints summary PCA results.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.pca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for ds.pca Objects ‚Äî print.ds.pca","text":"","code":"# S3 method for class 'ds.pca' print(x, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/print.ds.pca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for ds.pca Objects ‚Äî print.ds.pca","text":"x ds.pca object ... Additional arguments (ignored)","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/summary.ds.glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary Method for ds.glm Objects ‚Äî summary.ds.glm","title":"Summary Method for ds.glm Objects ‚Äî summary.ds.glm","text":"Prints detailed summary including deviance fit statistics.","code":""},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/summary.ds.glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary Method for ds.glm Objects ‚Äî summary.ds.glm","text":"","code":"# S3 method for class 'ds.glm' summary(object, ...)"},{"path":"https://isglobal-brge.github.io/dsVertClient/reference/summary.ds.glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary Method for ds.glm Objects ‚Äî summary.ds.glm","text":"object ds.glm object ... Additional arguments (ignored)","code":""}]
