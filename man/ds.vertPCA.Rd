% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ds.vertPCA.R
\name{ds.vertPCA}
\alias{ds.vertPCA}
\title{Principal Component Analysis for Vertically Partitioned Data}
\usage{
ds.vertPCA(
  data_name = NULL,
  variables = NULL,
  n_components = NULL,
  cor_result = NULL,
  log_n = 12,
  log_scale = 40,
  datasources = NULL
)
}
\arguments{
\item{data_name}{Character string. Name of the (aligned) data frame on
each server. Ignored if \code{cor_result} is provided.}

\item{variables}{A named list where each name corresponds to a server name
and each element is a character vector of variable names from that server.
Ignored if \code{cor_result} is provided.}

\item{n_components}{Integer. Number of principal components to return.
Default is NULL (returns all).}

\item{cor_result}{An existing \code{ds.cor} object from \code{\link{ds.vertCor}}.
If provided, the MHE protocol is NOT re-run; the PCA is computed directly
from this correlation matrix. This avoids running the expensive MHE protocol
twice when you already have the correlation.}

\item{log_n}{Integer. CKKS ring dimension parameter for MHE. Default is 12.
Ignored if \code{cor_result} is provided.}

\item{log_scale}{Integer. CKKS precision parameter for MHE. Default is 40.
Ignored if \code{cor_result} is provided.}

\item{datasources}{DataSHIELD connection object or list of connections.
If NULL, uses all available connections. Ignored if \code{cor_result} is
provided.}
}
\value{
A list with class "ds.pca" containing:
\itemize{
\item \code{loadings}: Matrix of variable loadings (n_vars x n_components)
\item \code{eigenvalues}: Eigenvalues for each component
\item \code{variance_pct}: Percentage of variance explained
\item \code{cumulative_pct}: Cumulative percentage explained
\item \code{var_names}: Variable names
\item \code{n_obs}: Number of observations
\item \code{correlation}: The correlation matrix used for PCA
}
}
\description{
Performs PCA on vertically partitioned data using the
privacy-preserving correlation matrix computed via Homomorphic Encryption.
}
\details{
This function performs PCA using the correlation matrix obtained via
Multiparty Homomorphic Encryption (MHE). The approach is:

\enumerate{
\item Compute the privacy-preserving correlation matrix using \code{\link{ds.vertCor}}
(or reuse an existing one via the \code{cor_result} parameter)
\item Perform eigen decomposition on the correlation matrix
\item Extract loadings (eigenvectors) and eigenvalues
}

Since PCA on standardized data is equivalent to eigen decomposition of the
correlation matrix, this gives correct loadings and variance explained.

\strong{Note on scores:} This function does NOT return principal component
scores because computing scores would require access to the raw data.
If you need scores, you would need to compute them on each server using
the loadings and aggregate the results (which is a separate operation).

\subsection{Interpreting Loadings}{
Each column of the loadings matrix represents a principal component.
The values show how much each variable contributes to that component:
\itemize{
\item Values close to 1 or -1 indicate strong contribution
\item Values close to 0 indicate weak contribution
\item Sign indicates direction of relationship
}
}
}
\section{Security}{

This function inherits all security properties from \code{\link{ds.vertCor}}:
\itemize{
\item Individual observations are never exposed
\item The client cannot decrypt without all servers cooperating
\item Only aggregate statistics (correlation matrix) are revealed
}
}

\examples{
\dontrun{
vars <- list(
  server1 = c("age", "weight"),
  server2 = c("height", "bmi")
)

pca_result <- ds.vertPCA("D_aligned", vars, n_components = 3)

# Or reuse an existing correlation result (avoids running MHE again):
cor_result <- ds.vertCor("D_aligned", vars)
pca_result <- ds.vertPCA(cor_result = cor_result, n_components = 3)

# View variance explained
print(pca_result)

# Biplot of loadings for first two PCs
plot(pca_result$loadings[, 1], pca_result$loadings[, 2],
     xlim = c(-1, 1), ylim = c(-1, 1),
     xlab = paste0("PC1 (", round(pca_result$variance_pct[1], 1), "\%)"),
     ylab = paste0("PC2 (", round(pca_result$variance_pct[2], 1), "\%)"))
text(pca_result$loadings[, 1], pca_result$loadings[, 2],
     labels = pca_result$var_names, pos = 3)
abline(h = 0, v = 0, lty = 2)
}

}
\seealso{
\code{\link{ds.vertCor}} for correlation analysis
}
