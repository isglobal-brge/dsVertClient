% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ds.vertCor.R
\name{ds.vertCor}
\alias{ds.vertCor}
\title{Correlation Matrix for Vertically Partitioned Data}
\usage{
ds.vertCor(data_name, variables, datasources = NULL)
}
\arguments{
\item{data_name}{Character string. Name of the (aligned) data frame on
each server.}

\item{variables}{A named list where each name corresponds to a server name
and each element is a character vector of variable names from that server.}

\item{datasources}{DataSHIELD connection object or list of connections.
If NULL, uses all available connections.}
}
\value{
A correlation matrix with dimensions equal to the total number
of variables across all servers. Row and column names are the
variable names.
}
\description{
Client-side function that computes a correlation matrix
across vertically partitioned data using distributed Block SVD.
}
\details{
This function implements distributed correlation analysis using
Block Singular Value Decomposition:

\enumerate{
\item Each server computes U*D from SVD of its standardized variables
\item Client combines  into a single matrix
\item Client computes final SVD to get V and D
\item Correlation matrix = V * D^2 * V' (normalized)
}

This method is privacy-preserving because:
\itemize{
\item Individual U*D matrices cannot reconstruct original data
\item Only the combined correlation structure is revealed
}
}
\examples{
\dontrun{
# Define which variables are on which server
vars <- list(
  server1 = c("age", "weight"),
  server2 = c("height", "bmi"),
  server3 = c("glucose", "cholesterol")
)

# Compute correlation matrix
cor_matrix <- ds.vertCor("D_aligned", vars, datasources = conns)
print(cor_matrix)
}

}
\references{
Iwen, M. & Ong, B.W. (2016). A distributed and incremental SVD algorithm
for agglomerative data analysis on large networks. SIAM Journal on Matrix
Analysis and Applications.
}
\seealso{
\code{\link{ds.vertPCA}} for principal component analysis
}
